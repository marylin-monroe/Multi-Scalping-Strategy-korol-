// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © polypokrbinc
//@version=5

strategy("Multi Scalping Strategy [Dimkud Clone]", shorttitle="MSS Clone", overlay=true, pyramiding=3, default_qty_type=strategy.percent_of_equity, default_qty_value=10, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.1, calc_on_order_fills=true, calc_on_every_tick=false, max_labels_count=500, max_lines_count=500, max_bars_back=5000, process_orders_on_close=true, fill_orders_on_standard_ohlc=true)

// ===============================
// BASIC TRADING SETTINGS
// ===============================
basic_group = "═══════════ Basic Trading Settings ═══════════"
use_long_trades = input.bool(true, "Use Long Trades", group=basic_group)
use_short_trades = input.bool(true, "Use Short Trades", group=basic_group)
allow_entry_without_indicators = input.bool(false, "Allow Entry if NO Indicators Active?", group=basic_group)
entry_cooldown_bars = input.int(5, "Min Bars Between Entries", minval=0, maxval=100, group=basic_group)

// ===============================
// SIGNAL MEMORY VARIABLES
// ===============================
// Memory Length Constants
SIGNAL_MEMORY_DEFAULT = 5

// Signal Memory Variables for ALL Indicators
var int rsi_long_signal_bar = 0
var int rsi_short_signal_bar = 0
var int st_long_signal_bar = 0
var int st_short_signal_bar = 0
var int st2_long_signal_bar = 0
var int st2_short_signal_bar = 0
var int ma_long_signal_bar = 0
var int ma_short_signal_bar = 0
var int channel_long_signal_bar = 0
var int channel_short_signal_bar = 0
var int stoch_long_signal_bar = 0
var int stoch_short_signal_bar = 0
var int mfi_long_signal_bar = 0
var int mfi_short_signal_bar = 0
var int cci_long_signal_bar = 0
var int cci_short_signal_bar = 0
var int momentum_long_signal_bar = 0
var int momentum_short_signal_bar = 0
var int rvi_long_signal_bar = 0
var int rvi_short_signal_bar = 0
var int smi_long_signal_bar = 0
var int smi_short_signal_bar = 0
var int dmi_long_signal_bar = 0
var int dmi_short_signal_bar = 0
var int cmf_long_signal_bar = 0
var int cmf_short_signal_bar = 0
var int bop_long_signal_bar = 0
var int bop_short_signal_bar = 0
var int macd_long_signal_bar = 0
var int macd_short_signal_bar = 0
var int qqe_long_signal_bar = 0
var int qqe_short_signal_bar = 0
var int dynamic_rsi_long_signal_bar = 0
var int dynamic_rsi_short_signal_bar = 0
var int dynamic_mfi_long_signal_bar = 0
var int dynamic_mfi_short_signal_bar = 0
var int levels_long_signal_bar = 0
var int levels_short_signal_bar = 0
var int div_long_signal_bar = 0
var int div_short_signal_bar = 0
var int candle_long_signal_bar = 0
var int candle_short_signal_bar = 0
var int lrc_long_signal_bar = 0
var int lrc_short_signal_bar = 0
var int external1_long_signal_bar = 0
var int external1_short_signal_bar = 0
var int external2_long_signal_bar = 0
var int external2_short_signal_bar = 0
var int pinbar_ma_long_signal_bar = 0
var int pinbar_ma_short_signal_bar = 0
var int accumulation_long_signal_bar = 0
var int accumulation_short_signal_bar = 0
var int highlow_long_signal_bar = 0
var int highlow_short_signal_bar = 0

// Position management variables
var float trailing_stop_level = na
var bool breakeven_activated = false
var int last_entry_bar_index = 0

// Order Indent Variables
var float indent_target_price = na
var int indent_bar_counter = 0
var bool waiting_for_long_indent = false
var bool waiting_for_short_indent = false

// Multi TP tracking
var bool tp1_executed = false
var bool tp2_executed = false
var bool tp3_executed = false

// ===============================
// HELPER FUNCTIONS
// ===============================
ma_function(src, length, ma_type) =>
    result = switch ma_type
        "SMA" => ta.sma(src, length)
        "EMA" => ta.ema(src, length)
        "RMA" => ta.rma(src, length)
        "WMA" => ta.wma(src, length)
        "HMA" => ta.hma(src, length)
        "VWMA" => ta.vwma(src, length)
        "TEMA" => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            ema3 = ta.ema(ema2, length)
            3 * (ema1 - ema2) + ema3
        "DEMA" => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            2 * ema1 - ema2
        => ta.ema(src, length)
    result

// SuperTrend Function
calculate_supertrend(src_high, src_low, src_close, factor, period, prev_direction, prev_supertrend) =>
    src_hl2 = (src_high + src_low) / 2
    atr_val = ta.atr(period)
    upperBand = src_hl2 + factor * atr_val
    lowerBand = src_hl2 - factor * atr_val
    
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])
    
    lb = lowerBand > prevLowerBand or src_close[1] < prevLowerBand ? lowerBand : prevLowerBand
    ub = upperBand < prevUpperBand or src_close[1] > prevUpperBand ? upperBand : prevUpperBand
    
    direction = 1
    superTrend = 0.0
    
    if na(prev_supertrend)
        direction := 1
        superTrend := lb
    else
        if prev_supertrend == prevUpperBand
            direction := src_close <= ub ? -1 : 1
        else
            direction := src_close >= lb ? 1 : -1
        
        superTrend := direction == -1 ? ub : lb
    
    [superTrend, direction]

// ===============================
// VISUALIZATION SETTINGS
// ===============================
viz_group = "═══════════ Visualization ═══════════"
show_tp_sl = input.bool(true, "Display TP/SL Visualization", group=viz_group)
show_entry_signals = input.bool(true, "Show Entry Signals", group=viz_group)
show_all_signals = input.bool(false, "Show All Signals (even if position open)", group=viz_group)

// ===============================
// PERIOD AND DAYS SETTINGS
// ===============================
period_group = "═══════════ Period Settings ═══════════"
start_year = input.int(2022, "Start Year", minval=2000, maxval=2100, group=period_group)
stop_year = input.int(2025, "Stop Year", minval=2000, maxval=2100, group=period_group)

days_group = "═══════════ Days To Block ═══════════"
block_sunday = input.bool(false, "Su", group=days_group, inline="days1")
block_monday = input.bool(false, "Mo", group=days_group, inline="days1") 
block_tuesday = input.bool(false, "Tu", group=days_group, inline="days1")
block_wednesday = input.bool(false, "We", group=days_group, inline="days1")
block_thursday = input.bool(false, "Th", group=days_group, inline="days2")
block_friday = input.bool(false, "Fr", group=days_group, inline="days2")
block_saturday = input.bool(false, "Sa", group=days_group, inline="days2")

// ===============================
// TP/SL SETTINGS
// ===============================
tpsl_group = "═══════════ TP/SL Settings ═══════════"
take_profit_percent = input.float(2.0, "Take Profit (%)", minval=0.1, maxval=20.0, step=0.1, group=tpsl_group)
stop_loss_percent = input.float(1.5, "Stop Loss (%)", minval=0.1, maxval=50.0, step=0.1, group=tpsl_group)
sl_equals_tp = input.bool(false, "SL=TP ? (for optimization)", group=tpsl_group)
close_only_profit = input.bool(false, "Close only in Profit", group=tpsl_group)
min_profit_percent = input.float(0.1, "Min Profit % for Close", minval=0.01, maxval=2.0, step=0.01, group=tpsl_group)

// Reverse Orders
use_reverse_order_on_sl = input.bool(false, "Reverse order on SL", group=tpsl_group)
use_reverse_order_on_be = input.bool(false, "Reverse order on BE", group=tpsl_group)
reverse_qty_percent = input.int(100, "Reverse Order Size (%)", minval=10, maxval=200, group=tpsl_group)

// ===============================
// BREAKEVEN SETTINGS
// ===============================
be_group = "═══════════ Breakeven ═══════════"
use_breakeven = input.bool(false, "Activate Breakeven", group=be_group)
breakeven_activation = input.float(1.0, "(%) to Activate Breakeven", minval=0.1, maxval=10.0, step=0.01, group=be_group)
breakeven_level = input.float(0.1, "New Breakeven SL (%)", minval=0.0, maxval=5.0, step=0.01, group=be_group)

// ===============================
// MULTI TAKE PROFITS
// ===============================
mtp_group = "═══════════ Multi Take Profits ═══════════"
use_multi_tp = input.bool(false, "Use Multiple Take Profits", group=mtp_group)
tp1_percent = input.float(0.6, "TP1 Profit (%)", minval=0.1, maxval=10.0, step=0.1, group=mtp_group)
tp1_qty = input.int(25, "TP1 Quantity (%)", minval=10, maxval=90, group=mtp_group)
tp2_percent = input.float(1.0, "TP2 Profit (%)", minval=0.1, maxval=15.0, step=0.1, group=mtp_group)
tp2_qty = input.int(25, "TP2 Quantity (%)", minval=10, maxval=90, group=mtp_group)
tp3_percent = input.float(1.5, "TP3 Profit (%)", minval=0.1, maxval=20.0, step=0.1, group=mtp_group)
tp3_qty = input.int(25, "TP3 Quantity (%)", minval=10, maxval=90, group=mtp_group)

// ===============================
// PYRAMIDING SETTINGS
// ===============================
pyr_group = "═══════════ Pyramiding ═══════════"
use_pyramiding = input.bool(false, "Use Pyramiding", group=pyr_group)
pyramid_min_move = input.float(0.5, "Min price move for pyramiding (%)", minval=0.1, maxval=5.0, step=0.1, group=pyr_group)

// ===============================
// TRAILING STOP
// ===============================
trail_group = "═══════════ Trailing Stop ═══════════"
use_trailing_stop = input.bool(false, "Use Trailing Stop", group=trail_group)
trailing_activation = input.float(1.5, "Activate Trailing Stop at %", minval=0.1, maxval=10.0, step=0.1, group=trail_group)
trailing_distance = input.float(0.5, "Distance from price to Trailing Stop (%)", minval=0.1, maxval=5.0, step=0.1, group=trail_group)

// ===============================
// ORDER INDENT
// ===============================
indent_group = "═══════════ Order Indent ═══════════"
use_order_indent = input.bool(false, "Use Order Indent", group=indent_group)
indent_percent = input.float(0.1, "Indent in %", minval=-2.0, maxval=2.0, step=0.01, group=indent_group)
indent_cancel_bars = input.int(15, "Cancel Indent Order After X Bars", minval=1, maxval=50, group=indent_group)

// ===============================
// ATR STOP LOSS AND TAKE PROFIT
// ===============================
atr_group = "═══════════ ATR SL/TP ═══════════"
use_atr_stop_loss = input.bool(false, "Use ATR Stop Loss", group=atr_group)
atr_sl_length = input.int(14, "ATR SL Length", minval=1, maxval=50, group=atr_group)
atr_sl_multiplier = input.float(2.0, "ATR SL Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

use_atr_take_profit = input.bool(false, "Use ATR Take Profit", group=atr_group)
atr_tp_length = input.int(14, "ATR TP Length", minval=1, maxval=50, group=atr_group)
atr_tp_multiplier = input.float(2.0, "ATR TP Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

// ===============================
// RSI SETTINGS
// ===============================
rsi_group = "═══════════ RSI ═══════════"
use_rsi = input.bool(false, "Use RSI", group=rsi_group)
rsi_length = input.int(14, "RSI Length", minval=2, maxval=100, group=rsi_group)
rsi_oversold = input.float(30, "RSI Oversold", minval=10, maxval=50, group=rsi_group)
rsi_overbought = input.float(70, "RSI Overbought", minval=50, maxval=90, group=rsi_group)
rsi_condition = input.string("Oversold", "RSI Condition", options=["Oversold", "Overbought", "Cross Level Up", "Cross Level Down", "Custom Range"], group=rsi_group)
rsi_custom_min = input.float(30, "RSI Custom Min", minval=0, maxval=100, group=rsi_group)
rsi_custom_max = input.float(70, "RSI Custom Max", minval=0, maxval=100, group=rsi_group)
rsi_tf = input.timeframe("", "RSI Timeframe", group=rsi_group)
rsi_use_signal_memory = input.bool(false, "RSI Use Signal Memory", group=rsi_group)
rsi_memory_bars = input.int(5, "RSI Memory Bars", minval=1, maxval=50, group=rsi_group)

// ===============================
// SUPERTREND SETTINGS
// ===============================
st_group = "═══════════ SuperTrend ═══════════"
use_supertrend = input.bool(false, "Use SuperTrend", group=st_group)
st_period = input.int(10, "SuperTrend Period", minval=1, maxval=50, group=st_group)
st_factor = input.float(3.0, "SuperTrend Factor", minval=0.5, maxval=10.0, step=0.1, group=st_group)
st_signal_type = input.string("Trend Filter", "SuperTrend Signal", options=["Trend Change", "Trend Filter"], group=st_group)
st_tf = input.timeframe("", "SuperTrend Timeframe", group=st_group)
st_use_signal_memory = input.bool(false, "SuperTrend Use Signal Memory", group=st_group)
st_memory_bars = input.int(5, "SuperTrend Memory Bars", minval=1, maxval=50, group=st_group)

// SuperTrend #2
use_supertrend2 = input.bool(false, "Use SuperTrend #2", group=st_group)
st2_period = input.int(21, "SuperTrend #2 Period", minval=1, maxval=50, group=st_group)
st2_factor = input.float(2.0, "SuperTrend #2 Factor", minval=0.5, maxval=10.0, step=0.1, group=st_group)
st2_signal_type = input.string("Trend Filter", "SuperTrend #2 Signal", options=["Trend Change", "Trend Filter"], group=st_group)
st2_tf = input.timeframe("", "SuperTrend #2 Timeframe", group=st_group)
st2_use_signal_memory = input.bool(false, "SuperTrend #2 Use Signal Memory", group=st_group)
st2_memory_bars = input.int(5, "SuperTrend #2 Memory Bars", minval=1, maxval=50, group=st_group)

// ===============================
// MOVING AVERAGES
// ===============================
ma_group = "═══════════ Two Moving Averages ═══════════"
use_ma = input.bool(false, "Use Moving Averages", group=ma_group)
ma_fast_length = input.int(10, "Fast MA Length", minval=2, maxval=200, group=ma_group)
ma_slow_length = input.int(30, "Slow MA Length", minval=2, maxval=200, group=ma_group)
ma_fast_type = input.string("EMA", "Fast MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_slow_type = input.string("EMA", "Slow MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_signal_type = input.string("Cross", "MA Signal Type", options=["Cross", "Direction", "Opposite Trend"], group=ma_group)
ma_tf = input.timeframe("", "MA Timeframe", group=ma_group)
ma_use_signal_memory = input.bool(false, "MA Use Signal Memory", group=ma_group)
ma_memory_bars = input.int(5, "MA Memory Bars", minval=1, maxval=50, group=ma_group)

// ===============================
// CHANNELS
// ===============================
channel_group = "═══════════ Channels ═══════════"
use_channels = input.bool(false, "Use Channels", group=channel_group)
channel_type = input.string("Bollinger Bands", "Channel Type", options=["Bollinger Bands", "Keltner Channel"], group=channel_group)
channel_length = input.int(20, "Channel Length", minval=5, maxval=100, group=channel_group)
channel_multiplier = input.float(2.0, "Channel Multiplier", minval=0.5, maxval=5.0, step=0.1, group=channel_group)
channel_signal_type = input.string("Rebound", "Channel Signal", options=["Rebound", "Breakout"], group=channel_group)
channel_tf = input.timeframe("", "Channel Timeframe", group=channel_group)
channel_use_signal_memory = input.bool(false, "Channel Use Signal Memory", group=channel_group)
channel_memory_bars = input.int(5, "Channel Memory Bars", minval=1, maxval=50, group=channel_group)

// ===============================
// STOCHASTIC
// ===============================
stoch_group = "═══════════ Stochastic ═══════════"
use_stochastic = input.bool(false, "Use Stochastic", group=stoch_group)
stoch_k_length = input.int(14, "Stochastic %K Length", minval=1, maxval=100, group=stoch_group)
stoch_k_smooth = input.int(1, "Stochastic %K Smoothing", minval=1, maxval=10, group=stoch_group)
stoch_d_smooth = input.int(3, "Stochastic %D Smoothing", minval=1, maxval=10, group=stoch_group)
stoch_overbought = input.float(80, "Stochastic Overbought", minval=50, maxval=100, group=stoch_group)
stoch_oversold = input.float(20, "Stochastic Oversold", minval=0, maxval=50, group=stoch_group)
stoch_signal_type = input.string("Oversold Cross", "Stochastic Signal", options=["Oversold Cross", "Overbought Cross", "K-D Cross"], group=stoch_group)
stoch_use_signal_memory = input.bool(false, "Stochastic Use Signal Memory", group=stoch_group)
stoch_memory_bars = input.int(5, "Stochastic Memory Bars", minval=1, maxval=50, group=stoch_group)

// ===============================
// ADDITIONAL INDICATORS
// ===============================
// MFI
mfi_group = "═══════════ MFI ═══════════"
use_mfi = input.bool(false, "Use MFI", group=mfi_group)
mfi_length = input.int(14, "MFI Length", minval=2, maxval=100, group=mfi_group)
mfi_overbought = input.float(80, "MFI Overbought", minval=50, maxval=90, group=mfi_group)
mfi_oversold = input.float(20, "MFI Oversold", minval=10, maxval=50, group=mfi_group)
mfi_use_signal_memory = input.bool(false, "MFI Use Signal Memory", group=mfi_group)
mfi_memory_bars = input.int(5, "MFI Memory Bars", minval=1, maxval=50, group=mfi_group)

// CCI
cci_group = "═══════════ CCI ═══════════"
use_cci = input.bool(false, "Use CCI", group=cci_group)
cci_length = input.int(20, "CCI Length", minval=5, maxval=200, group=cci_group)
cci_overbought = input.float(100, "CCI Overbought", minval=50, maxval=200, group=cci_group)
cci_oversold = input.float(-100, "CCI Oversold", minval=-200, maxval=-50, group=cci_group)
cci_use_signal_memory = input.bool(false, "CCI Use Signal Memory", group=cci_group)
cci_memory_bars = input.int(5, "CCI Memory Bars", minval=1, maxval=50, group=cci_group)

// MACD
macd_group = "═══════════ MACD ═══════════"
use_macd = input.bool(false, "Use MACD", group=macd_group)
macd_fast_length = input.int(12, "MACD Fast Length", minval=2, maxval=50, group=macd_group)
macd_slow_length = input.int(26, "MACD Slow Length", minval=5, maxval=100, group=macd_group)
macd_signal_length = input.int(9, "MACD Signal Length", minval=2, maxval=50, group=macd_group)
macd_condition = input.string("Signal Cross", "MACD Signal", options=["Signal Cross", "Zero Cross"], group=macd_group)
macd_use_signal_memory = input.bool(false, "MACD Use Signal Memory", group=macd_group)
macd_memory_bars = input.int(5, "MACD Memory Bars", minval=1, maxval=50, group=macd_group)

// RVI
rvi_group = "═══════════ RVI ═══════════"
use_rvi = input.bool(false, "Use RVI", group=rvi_group)
rvi_length = input.int(10, "RVI Length", minval=2, maxval=100, group=rvi_group)
rvi_overbought = input.float(80, "RVI Overbought", minval=50, maxval=90, group=rvi_group)
rvi_oversold = input.float(20, "RVI Oversold", minval=10, maxval=50, group=rvi_group)
rvi_use_signal_memory = input.bool(false, "RVI Use Signal Memory", group=rvi_group)
rvi_memory_bars = input.int(5, "RVI Memory Bars", minval=1, maxval=50, group=rvi_group)

// Momentum
momentum_group = "═══════════ Momentum ═══════════"
use_momentum = input.bool(false, "Use Momentum", group=momentum_group)
momentum_length = input.int(10, "Momentum Length", minval=1, maxval=100, group=momentum_group)
momentum_overbought = input.float(100, "Momentum Overbought", minval=50, maxval=200, group=momentum_group)
momentum_oversold = input.float(-100, "Momentum Oversold", minval=-200, maxval=-50, group=momentum_group)
momentum_use_signal_memory = input.bool(false, "Momentum Use Signal Memory", group=momentum_group)
momentum_memory_bars = input.int(5, "Momentum Memory Bars", minval=1, maxval=50, group=momentum_group)

// SMI (Stochastic Momentum Index)
smi_group = "═══════════ SMI Ergodic ═══════════"
use_smi = input.bool(false, "Use SMI Ergodic", group=smi_group)
smi_k_length = input.int(5, "SMI %K Length", minval=1, maxval=100, group=smi_group)
smi_d_length = input.int(3, "SMI %D Length", minval=1, maxval=100, group=smi_group)
smi_rsi_length = input.int(14, "SMI RSI Length", minval=2, maxval=100, group=smi_group)
smi_stoch_length = input.int(14, "SMI Stoch Length", minval=2, maxval=100, group=smi_group)
smi_overbought = input.float(40, "SMI Overbought", minval=20, maxval=80, group=smi_group)
smi_oversold = input.float(-40, "SMI Oversold", minval=-80, maxval=-20, group=smi_group)
smi_use_signal_memory = input.bool(false, "SMI Use Signal Memory", group=smi_group)
smi_memory_bars = input.int(5, "SMI Memory Bars", minval=1, maxval=50, group=smi_group)

// DMI (Directional Movement Index)
dmi_group = "═══════════ DMI ═══════════"
use_dmi = input.bool(false, "Use DMI", group=dmi_group)
dmi_length = input.int(14, "DMI Length", minval=1, maxval=100, group=dmi_group)
dmi_adx_threshold = input.float(25, "ADX Threshold", minval=10, maxval=50, group=dmi_group)
dmi_use_signal_memory = input.bool(false, "DMI Use Signal Memory", group=dmi_group)
dmi_memory_bars = input.int(5, "DMI Memory Bars", minval=1, maxval=50, group=dmi_group)

// CMF (Chaikin Money Flow)
cmf_group = "═══════════ CMF ═══════════"
use_cmf = input.bool(false, "Use CMF", group=cmf_group)
cmf_length = input.int(20, "CMF Length", minval=1, maxval=100, group=cmf_group)
cmf_overbought = input.float(0.2, "CMF Overbought", minval=0.1, maxval=0.5, group=cmf_group)
cmf_oversold = input.float(-0.2, "CMF Oversold", minval=-0.5, maxval=-0.1, group=cmf_group)
cmf_use_signal_memory = input.bool(false, "CMF Use Signal Memory", group=cmf_group)
cmf_memory_bars = input.int(5, "CMF Memory Bars", minval=1, maxval=50, group=cmf_group)

// BOP (Balance of Power)
bop_group = "═══════════ BOP ═══════════"
use_bop = input.bool(false, "Use BOP", group=bop_group)
bop_length = input.int(14, "BOP Length", minval=1, maxval=100, group=bop_group)
bop_overbought = input.float(0.8, "BOP Overbought", minval=0.3, maxval=1.0, group=bop_group)
bop_oversold = input.float(-0.8, "BOP Oversold", minval=-1.0, maxval=-0.3, group=bop_group)
bop_use_signal_memory = input.bool(false, "BOP Use Signal Memory", group=bop_group)
bop_memory_bars = input.int(5, "BOP Memory Bars", minval=1, maxval=50, group=bop_group)

// QQE Signals
qqe_group = "═══════════ QQE Signals ═══════════"
use_qqe = input.bool(false, "Use QQE", group=qqe_group)
qqe_rsi_length = input.int(14, "QQE RSI Length", minval=2, maxval=100, group=qqe_group)
qqe_rsi_smoothing = input.int(5, "QQE RSI Smoothing", minval=1, maxval=50, group=qqe_group)
qqe_fast_factor = input.float(2.618, "QQE Fast Factor", minval=0.1, maxval=10.0, step=0.1, group=qqe_group)
qqe_use_signal_memory = input.bool(false, "QQE Use Signal Memory", group=qqe_group)
qqe_memory_bars = input.int(5, "QQE Memory Bars", minval=1, maxval=50, group=qqe_group)

// Dynamic RSI
dynamic_rsi_group = "═══════════ Dynamic RSI ═══════════"
use_dynamic_rsi = input.bool(false, "Use Dynamic RSI", group=dynamic_rsi_group)
dynamic_rsi_length = input.int(14, "Dynamic RSI Length", minval=2, maxval=100, group=dynamic_rsi_group)
dynamic_rsi_band_length = input.int(20, "Dynamic RSI Band Length", minval=5, maxval=100, group=dynamic_rsi_group)
dynamic_rsi_use_signal_memory = input.bool(false, "Dynamic RSI Use Signal Memory", group=dynamic_rsi_group)
dynamic_rsi_memory_bars = input.int(5, "Dynamic RSI Memory Bars", minval=1, maxval=50, group=dynamic_rsi_group)

// Dynamic MFI
dynamic_mfi_group = "═══════════ Dynamic MFI ═══════════"
use_dynamic_mfi = input.bool(false, "Use Dynamic MFI", group=dynamic_mfi_group)
dynamic_mfi_length = input.int(14, "Dynamic MFI Length", minval=2, maxval=100, group=dynamic_mfi_group)
dynamic_mfi_band_length = input.int(20, "Dynamic MFI Band Length", minval=5, maxval=100, group=dynamic_mfi_group)
dynamic_mfi_use_signal_memory = input.bool(false, "Dynamic MFI Use Signal Memory", group=dynamic_mfi_group)
dynamic_mfi_memory_bars = input.int(5, "Dynamic MFI Memory Bars", minval=1, maxval=50, group=dynamic_mfi_group)

// ===============================
// SIGNAL INDICATORS
// ===============================
signals_group = "═══════════ Signal Indicators ═══════════"

// Highest/Lowest Bar
use_highlow = input.bool(false, "Use Highest/Lowest Bar", group=signals_group)
highlow_period = input.int(20, "High/Low Period", minval=5, maxval=200, group=signals_group)
highlow_use_signal_memory = input.bool(false, "High/Low Use Signal Memory", group=signals_group)
highlow_memory_bars = input.int(5, "High/Low Memory Bars", minval=1, maxval=50, group=signals_group)

// Accumulation Areas
use_accumulation = input.bool(false, "Use Accumulation Areas", group=signals_group)
accumulation_length = input.int(20, "Accumulation Length", minval=5, maxval=100, group=signals_group)
accumulation_range = input.float(1.0, "Max Range % for Accumulation", minval=0.1, maxval=5.0, step=0.1, group=signals_group)
accumulation_use_signal_memory = input.bool(false, "Accumulation Use Signal Memory", group=signals_group)
accumulation_memory_bars = input.int(5, "Accumulation Memory Bars", minval=1, maxval=50, group=signals_group)

// Pin Bar + MA
use_pinbar_ma = input.bool(false, "Use Pin Bar + MA", group=signals_group)
pinbar_ma_length = input.int(21, "Pin Bar MA Length", minval=5, maxval=200, group=signals_group)
pinbar_ma_use_signal_memory = input.bool(false, "Pin Bar MA Use Signal Memory", group=signals_group)
pinbar_ma_memory_bars = input.int(5, "Pin Bar MA Memory Bars", minval=1, maxval=50, group=signals_group)

// Levels
levels_group = "═══════════ Levels ═══════════"
use_levels = input.bool(false, "Use Levels", group=levels_group)
levels_high = input.float(100.0, "High Level", minval=0.1, group=levels_group)
levels_low = input.float(0.0, "Low Level", minval=0.0, group=levels_group)
levels_distance = input.float(1.0, "Distance to Level %", minval=0.1, maxval=10.0, step=0.1, group=levels_group)
levels_use_signal_memory = input.bool(false, "Levels Use Signal Memory", group=levels_group)
levels_memory_bars = input.int(5, "Levels Memory Bars", minval=1, maxval=50, group=levels_group)

// Divergences
div_group = "═══════════ Divergences ═══════════"
use_divergences = input.bool(false, "Use Divergences", group=div_group)
div_rsi_length = input.int(14, "Divergence RSI Length", minval=2, maxval=100, group=div_group)
div_pivot_length = input.int(5, "Divergence Pivot Length", minval=2, maxval=50, group=div_group)
div_use_signal_memory = input.bool(false, "Divergences Use Signal Memory", group=div_group)
div_memory_bars = input.int(5, "Divergences Memory Bars", minval=1, maxval=50, group=div_group)

// Candle Patterns
candle_group = "═══════════ Candle Patterns ═══════════"
use_candle_patterns = input.bool(false, "Use Candle Patterns", group=candle_group)
candle_use_signal_memory = input.bool(false, "Candle Patterns Use Signal Memory", group=candle_group)
candle_memory_bars = input.int(5, "Candle Patterns Memory Bars", minval=1, maxval=50, group=candle_group)

// Linear Regression Channel
lrc_group = "═══════════ Linear Regression Channel ═══════════"
use_lrc = input.bool(false, "Use Linear Regression Channel", group=lrc_group)
lrc_length = input.int(100, "LRC Length", minval=10, maxval=500, group=lrc_group)
lrc_deviation = input.float(2.0, "LRC Deviation", minval=0.5, maxval=5.0, step=0.1, group=lrc_group)
lrc_use_signal_memory = input.bool(false, "LRC Use Signal Memory", group=lrc_group)
lrc_memory_bars = input.int(5, "LRC Memory Bars", minval=1, maxval=50, group=lrc_group)

// External Indicators
external_group = "═══════════ External Indicators ═══════════"
use_external1 = input.bool(false, "Use External Indicator #1", group=external_group)
external1_source = input.source(close, "External #1 Source", group=external_group)
external1_condition = input.string("Above Zero", "External #1 Condition", options=["Above Zero", "Below Zero", "Cross Up", "Cross Down"], group=external_group)
external1_use_signal_memory = input.bool(false, "External #1 Use Signal Memory", group=external_group)
external1_memory_bars = input.int(5, "External #1 Memory Bars", minval=1, maxval=50, group=external_group)

use_external2 = input.bool(false, "Use External Indicator #2", group=external_group)
external2_source = input.source(close, "External #2 Source", group=external_group)
external2_condition = input.string("Above Zero", "External #2 Condition", options=["Above Zero", "Below Zero", "Cross Up", "Cross Down"], group=external_group)
external2_use_signal_memory = input.bool(false, "External #2 Use Signal Memory", group=external_group)
external2_memory_bars = input.int(5, "External #2 Memory Bars", minval=1, maxval=50, group=external_group)

// ===============================
// FILTERS
// ===============================
filters_group = "═══════════ Filters ═══════════"

// Volume Filter
use_volume_filter = input.bool(false, "Use Volume Filter", group=filters_group)
volume_length = input.int(20, "Volume Length", minval=5, maxval=100, group=filters_group)
volume_multiplier = input.float(1.5, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1, group=filters_group)

// Volatility Filter (ATR)
use_volatility_filter = input.bool(false, "Use Volatility Filter", group=filters_group)
volatility_length = input.int(20, "Volatility Length", minval=5, maxval=100, group=filters_group)
volatility_threshold = input.float(1.0, "Volatility Threshold", minval=0.1, maxval=10.0, step=0.1, group=filters_group)

// Price Movement Filter
use_price_filter = input.bool(false, "Use Price Movement Filter", group=filters_group)
price_min_change = input.float(0.5, "Min Price Change %", minval=0.1, maxval=10.0, step=0.1, group=filters_group)
price_period = input.int(10, "Price Change Period", minval=1, maxval=50, group=filters_group)

// ATR Growth Filter
use_atr_growth_filter = input.bool(false, "Use ATR Growth Filter", group=filters_group)
atr_growth_length = input.int(20, "ATR Growth Length", minval=5, maxval=100, group=filters_group)
atr_growth_multiplier = input.float(1.2, "ATR Growth Multiplier", minval=1.0, maxval=3.0, step=0.1, group=filters_group)

// Block if Worse Than Filter
use_block_worse = input.bool(false, "Block if Worse Than", group=filters_group)
block_worse_percent = input.float(0.5, "Block if Price Moved %", minval=0.1, maxval=5.0, step=0.1, group=filters_group)

// SuperTrend Trend Filter
use_st_trend_filter = input.bool(false, "Use SuperTrend Trend Filter", group=filters_group)
st_trend_period = input.int(10, "ST Trend Filter Period", minval=1, maxval=50, group=filters_group)
st_trend_factor = input.float(3.0, "ST Trend Filter Factor", minval=0.5, maxval=10.0, step=0.1, group=filters_group)

// ===============================
// CLOSE CONDITIONS
// ===============================
close_group = "═══════════ Close Conditions ═══════════"
close_by_rsi = input.bool(false, "Close by RSI", group=close_group)
close_by_channel = input.bool(false, "Close by Channel", group=close_group)
close_by_ma_cross = input.bool(false, "Close by MA Cross", group=close_group)
close_by_qqe = input.bool(false, "Close by QQE", group=close_group)
close_by_lrc = input.bool(false, "Close by Linear Regression Channel", group=close_group)
close_by_levels = input.bool(false, "Close by Levels", group=close_group)

// ===============================
// INDICATOR CALCULATIONS
// ===============================

// Time filters
date_filter = year >= start_year and year <= stop_year
day_blocked = (block_sunday and dayofweek == dayofweek.sunday) or 
              (block_monday and dayofweek == dayofweek.monday) or 
              (block_tuesday and dayofweek == dayofweek.tuesday) or 
              (block_wednesday and dayofweek == dayofweek.wednesday) or 
              (block_thursday and dayofweek == dayofweek.thursday) or 
              (block_friday and dayofweek == dayofweek.friday) or 
              (block_saturday and dayofweek == dayofweek.saturday)
time_trade_allowed = date_filter and not day_blocked

// Pre-calculate all ta.* functions to avoid scope issues
atr_14 = ta.atr(14)
atr_sl_val = ta.atr(atr_sl_length)
atr_tp_val = ta.atr(atr_tp_length)

// SuperTrend calculations
var float st_line = na
var int st_direction = 1
[st_new_line, st_new_dir] = calculate_supertrend(high, low, close, st_factor, st_period, st_direction, st_line)
st_line := st_new_line
st_direction := st_new_dir

var float st2_line = na
var int st2_direction = 1
[st2_new_line, st2_new_dir] = calculate_supertrend(high, low, close, st2_factor, st2_period, st2_direction, st2_line)
st2_line := st2_new_line
st2_direction := st2_new_dir



// Volume and Volatility
volume_avg = ta.sma(volume, volume_length)
volatility_calc = ta.stdev(close, volatility_length) / ta.sma(close, volatility_length) * 100

// Additional filter calculations
// Price movement filter
price_change = math.abs(close - close[price_period]) / close[price_period] * 100

// ATR growth filter
atr_current = ta.atr(14)
atr_avg = ta.sma(atr_current, atr_growth_length)
atr_growth = atr_current / atr_avg

// Block if worse than filter
price_move_current_bar = math.abs(close - close[1]) / close[1] * 100

// SuperTrend trend filter
var float st_trend_line = na
var int st_trend_direction = 1
[st_trend_new_line, st_trend_new_dir] = calculate_supertrend(high, low, close, st_trend_factor, st_trend_period, st_trend_direction, st_trend_line)
st_trend_line := st_trend_new_line
st_trend_direction := st_trend_new_dir

// Pin Bar detection
pin_bar_detection() =>
    body = math.abs(close - open)
    upper_shadow = high - math.max(open, close)
    lower_shadow = math.min(open, close) - low
    total_range = high - low
    
    // Long pin bar (hammer)
    long_pin = lower_shadow > body * 2 and upper_shadow < body * 0.5 and total_range > atr_14 * 0.5
    // Short pin bar (shooting star)
    short_pin = upper_shadow > body * 2 and lower_shadow < body * 0.5 and total_range > atr_14 * 0.5
    
    [long_pin, short_pin]

[pin_long, pin_short] = pin_bar_detection()

// RSI crossovers for different conditions
rsi_cross_up_oversold = ta.crossover(rsi_calc, rsi_oversold)
rsi_cross_down_overbought = ta.crossunder(rsi_calc, rsi_overbought)
rsi_cross_down_overbought_2 = ta.crossunder(rsi_calc, rsi_overbought)
rsi_cross_up_oversold_2 = ta.crossover(rsi_calc, rsi_oversold)

// MACD crossovers
macd_cross_signal_up = ta.crossover(macd_line, macd_signal)
macd_cross_signal_down = ta.crossunder(macd_line, macd_signal)
macd_cross_zero_up = ta.crossover(macd_line, 0)
macd_cross_zero_down = ta.crossunder(macd_line, 0)

// Stochastic crossovers
stoch_cross_oversold_up = ta.crossover(stoch_k_calc, stoch_oversold)
stoch_cross_overbought_down = ta.crossunder(stoch_k_calc, stoch_overbought)
stoch_cross_overbought_down_2 = ta.crossunder(stoch_k_calc, stoch_overbought)
stoch_cross_oversold_up_2 = ta.crossover(stoch_k_calc, stoch_oversold)
stoch_k_cross_d_up = ta.crossover(stoch_k_calc, stoch_d_calc)
stoch_k_cross_d_down = ta.crossunder(stoch_k_calc, stoch_d_calc)

// Moving Average crossovers
ma_fast_cross_slow_up = ta.crossover(ma_fast_calc, ma_slow_calc)
ma_fast_cross_slow_down = ta.crossunder(ma_fast_calc, ma_slow_calc)

// CMF and BOP crossovers
cmf_cross_zero_up = ta.crossover(cmf_value, 0)
cmf_cross_zero_down = ta.crossunder(cmf_value, 0)
bop_cross_zero_up = ta.crossover(bop_value, 0)
bop_cross_zero_down = ta.crossunder(bop_value, 0)

// External indicators crossovers
external1_cross_zero_up = ta.crossover(external1_source, 0)
external1_cross_zero_down = ta.crossunder(external1_source, 0)
external2_cross_zero_up = ta.crossover(external2_source, 0)
external2_cross_zero_down = ta.crossunder(external2_source, 0)

// Moving Averages
ma_fast_calc = ma_function(close, ma_fast_length, ma_fast_type)
ma_slow_calc = ma_function(close, ma_slow_length, ma_slow_type)

// Bollinger Bands / Keltner Channel
channel_basis = channel_type == "Bollinger Bands" ? ta.sma(close, channel_length) : ta.ema(close, channel_length)
channel_dev = channel_type == "Bollinger Bands" ? channel_multiplier * ta.stdev(close, channel_length) : channel_multiplier * ta.atr(channel_length)
channel_upper = channel_basis + channel_dev
channel_lower = channel_basis - channel_dev

// RSI with MTF
rsi_calc = rsi_tf == "" ? ta.rsi(close, rsi_length) : request.security(syminfo.tickerid, rsi_tf, ta.rsi(close, rsi_length), lookahead=barmerge.lookahead_off)

// Other indicators
stoch_k_raw = ta.stoch(close, high, low, stoch_k_length)
stoch_k_calc = ta.sma(stoch_k_raw, stoch_k_smooth)
stoch_d_calc = ta.sma(stoch_k_calc, stoch_d_smooth)

mfi_calc = ta.mfi(hlc3, mfi_length)
cci_calc = ta.cci(hlc3, cci_length)
[macd_line, macd_signal, macd_hist] = ta.macd(close, macd_fast_length, macd_slow_length, macd_signal_length)

// RVI calculation
rvi_calc() =>
    co = close - open
    hl = high - low
    co_ma = ta.sma(co, rvi_length)
    hl_ma = ta.sma(hl, rvi_length)
    hl_ma == 0 ? 50 : (co_ma / hl_ma * 100 + 100) / 2

rvi_value = rvi_calc()

// Momentum calculation
momentum_calc = ta.mom(close, momentum_length)

// SMI Ergodic calculation
smi_calc() =>
    rsi_val = ta.rsi(close, smi_rsi_length)
    stoch_val = ta.stoch(rsi_val, rsi_val, rsi_val, smi_stoch_length)
    k_val = ta.sma(stoch_val, smi_k_length)
    d_val = ta.sma(k_val, smi_d_length)
    k_val - 50

smi_value = smi_calc()

// DMI calculation
[di_plus, di_minus, adx] = ta.dmi(dmi_length, dmi_length)

// CMF calculation
cmf_calc() =>
    money_flow_multiplier = ((close - low) - (high - close)) / (high - low)
    money_flow_volume = money_flow_multiplier * volume
    ta.sma(money_flow_volume, cmf_length) / ta.sma(volume, cmf_length)

cmf_value = cmf_calc()

// BOP calculation
bop_calc() =>
    raw_bop = (close - open) / (high - low)
    ta.sma(raw_bop, bop_length)

bop_value = bop_calc()

// QQE calculation
qqe_calc() =>
    rsi_val = ta.rsi(close, qqe_rsi_length)
    rsi_ma = ta.ema(rsi_val, qqe_rsi_smoothing)
    dar = ta.ema(math.abs(rsi_ma - rsi_ma[1]), qqe_rsi_smoothing) * qqe_fast_factor
    long_band = 0.0
    short_band = 0.0
    trend = 0
    
    long_band := rsi_ma + dar
    short_band := rsi_ma - dar
    
    trend := rsi_ma > long_band[1] ? 1 : rsi_ma < short_band[1] ? -1 : nz(trend[1])
    
    [long_band, short_band, trend]

[qqe_up, qqe_down, qqe_trend] = qqe_calc()

// Dynamic RSI calculation
dynamic_rsi_calc() =>
    rsi_val = ta.rsi(close, dynamic_rsi_length)
    rsi_upper = ta.highest(rsi_val, dynamic_rsi_band_length)
    rsi_lower = ta.lowest(rsi_val, dynamic_rsi_band_length)
    [rsi_val, rsi_upper, rsi_lower]

[d_rsi, d_rsi_upper, d_rsi_lower] = dynamic_rsi_calc()

// Dynamic MFI calculation
dynamic_mfi_calc() =>
    mfi_val = ta.mfi(hlc3, dynamic_mfi_length)
    mfi_upper = ta.highest(mfi_val, dynamic_mfi_band_length)
    mfi_lower = ta.lowest(mfi_val, dynamic_mfi_band_length)
    [mfi_val, mfi_upper, mfi_lower]

[d_mfi, d_mfi_upper, d_mfi_lower] = dynamic_mfi_calc()

// Linear Regression Channel calculation
lrc_calc() =>
    sum_x = 0.0
    sum_y = 0.0
    sum_xy = 0.0
    sum_x2 = 0.0
    
    for i = 0 to lrc_length - 1
        x = i
        y = close[i]
        sum_x += x
        sum_y += y
        sum_xy += x * y
        sum_x2 += x * x
    
    slope = (lrc_length * sum_xy - sum_x * sum_y) / (lrc_length * sum_x2 - sum_x * sum_x)
    intercept = (sum_y - slope * sum_x) / lrc_length
    
    regression_line = intercept + slope * (lrc_length - 1)
    deviation = ta.stdev(close, lrc_length) * lrc_deviation
    
    [regression_line, regression_line + deviation, regression_line - deviation]

[lrc_mid, lrc_upper, lrc_lower] = lrc_calc()

// Divergence detection
divergence_calc() =>
    rsi_val = ta.rsi(close, div_rsi_length)
    
    ph = ta.pivothigh(high, div_pivot_length, div_pivot_length)
    pl = ta.pivotlow(low, div_pivot_length, div_pivot_length)
    
    phr = ta.pivothigh(rsi_val, div_pivot_length, div_pivot_length)
    plr = ta.pivotlow(rsi_val, div_pivot_length, div_pivot_length)
    
    bull_div = not na(pl) and not na(plr) and low < low[div_pivot_length * 2] and rsi_val > rsi_val[div_pivot_length * 2]
    bear_div = not na(ph) and not na(phr) and high > high[div_pivot_length * 2] and rsi_val < rsi_val[div_pivot_length * 2]
    
    [bull_div, bear_div]

[bullish_div, bearish_div] = divergence_calc()

// Candle patterns detection
candle_patterns() =>
    // Doji
    doji = math.abs(close - open) <= (high - low) * 0.1
    
    // Hammer
    hammer = (close > open) and ((close - open) / (0.001 + high - low) > 0.6) and ((open - low) / (0.001 + high - low) > 0.6)
    
    // Shooting Star
    shooting_star = (open > close) and ((high - open) / (0.001 + high - low) > 0.6) and ((close - low) / (0.001 + high - low) > 0.6)
    
    // Engulfing
    bull_engulf = (close > open) and (close[1] < open[1]) and (close > open[1]) and (open < close[1])
    bear_engulf = (close < open) and (close[1] > open[1]) and (close < open[1]) and (open > close[1])
    
    candle_long = hammer or bull_engulf
    candle_short = shooting_star or bear_engulf
    
    [candle_long, candle_short]

[candle_bull, candle_bear] = candle_patterns()

// Volume and Volatility
volume_avg = ta.sma(volume, volume_length)
volatility_calc = ta.stdev(close, volatility_length) / ta.sma(close, volatility_length) * 100

// Additional filter calculations
// Price movement filter
price_change = math.abs(close - close[price_period]) / close[price_period] * 100

// ATR growth filter
atr_current = ta.atr(14)
atr_avg = ta.sma(atr_current, atr_growth_length)
atr_growth = atr_current / atr_avg

// Block if worse than filter
price_move_current_bar = math.abs(close - close[1]) / close[1] * 100

// SuperTrend trend filter
var float st_trend_line = na
var int st_trend_direction = 1
[st_trend_new_line, st_trend_new_dir] = calculate_supertrend(high, low, close, st_trend_factor, st_trend_period, st_trend_direction, st_trend_line)
st_trend_line := st_trend_new_line
st_trend_direction := st_trend_new_dir



// ===============================
// SIGNAL ARCHITECTURE WITH MEMORY
// ===============================

// Initialize counters
var int active_conditions_long = 0
var int met_conditions_long = 0
var int active_conditions_short = 0
var int met_conditions_short = 0

// Reset counters
active_conditions_long := 0
met_conditions_long := 0
active_conditions_short := 0
met_conditions_short := 0

// RSI Signals with Memory
if use_rsi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    rsi_long_pure = false
    rsi_short_pure = false
    
    if rsi_condition == "Oversold"
        rsi_long_pure := rsi_calc <= rsi_oversold
        rsi_short_pure := rsi_calc >= rsi_overbought
    else if rsi_condition == "Overbought"
        rsi_long_pure := rsi_calc >= rsi_overbought
        rsi_short_pure := rsi_calc <= rsi_oversold
    else if rsi_condition == "Cross Level Up"
        rsi_long_pure := rsi_cross_up_oversold
        rsi_short_pure := rsi_cross_down_overbought
    else if rsi_condition == "Cross Level Down"
        rsi_long_pure := rsi_cross_down_overbought_2
        rsi_short_pure := rsi_cross_up_oversold_2
    else if rsi_condition == "Custom Range"
        rsi_long_pure := rsi_calc >= rsi_custom_min and rsi_calc <= rsi_custom_max
        rsi_short_pure := rsi_calc <= rsi_custom_min or rsi_calc >= rsi_custom_max
    
    // Update signal memory
    if rsi_long_pure
        rsi_long_signal_bar := bar_index
    if rsi_short_pure
        rsi_short_signal_bar := bar_index
    
    // Final signals (pure OR memory)
    rsi_long_final = rsi_long_pure or (rsi_use_signal_memory and bar_index - rsi_long_signal_bar <= rsi_memory_bars)
    rsi_short_final = rsi_short_pure or (rsi_use_signal_memory and bar_index - rsi_short_signal_bar <= rsi_memory_bars)
    
    if rsi_long_final
        met_conditions_long += 1
    if rsi_short_final
        met_conditions_short += 1

// SuperTrend Signals with Memory
if use_supertrend
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    st_long_pure = false
    st_short_pure = false
    
    if st_signal_type == "Trend Change"
        st_long_pure := st_direction == 1 and st_direction[1] == -1
        st_short_pure := st_direction == -1 and st_direction[1] == 1
    else if st_signal_type == "Trend Filter"
        st_long_pure := st_direction == 1
        st_short_pure := st_direction == -1
    
    // Update signal memory
    if st_long_pure
        st_long_signal_bar := bar_index
    if st_short_pure
        st_short_signal_bar := bar_index
    
    // Final signals
    st_long_final = st_long_pure or (st_use_signal_memory and bar_index - st_long_signal_bar <= st_memory_bars)
    st_short_final = st_short_pure or (st_use_signal_memory and bar_index - st_short_signal_bar <= st_memory_bars)
    
    if st_long_final
        met_conditions_long += 1
    if st_short_final
        met_conditions_short += 1

// SuperTrend #2 Signals with Memory
if use_supertrend2
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    st2_long_pure = false
    st2_short_pure = false
    
    if st2_signal_type == "Trend Change"
        st2_long_pure := st2_direction == 1 and st2_direction[1] == -1
        st2_short_pure := st2_direction == -1 and st2_direction[1] == 1
    else if st2_signal_type == "Trend Filter"
        st2_long_pure := st2_direction == 1
        st2_short_pure := st2_direction == -1
    
    // Update signal memory
    if st2_long_pure
        st2_long_signal_bar := bar_index
    if st2_short_pure
        st2_short_signal_bar := bar_index
    
    // Final signals
    st2_long_final = st2_long_pure or (st2_use_signal_memory and bar_index - st2_long_signal_bar <= st2_memory_bars)
    st2_short_final = st2_short_pure or (st2_use_signal_memory and bar_index - st2_short_signal_bar <= st2_memory_bars)
    
    if st2_long_final
        met_conditions_long += 1
    if st2_short_final
        met_conditions_short += 1

// Moving Averages Signals with Memory
if use_ma
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    ma_long_pure = false
    ma_short_pure = false
    
    if ma_signal_type == "Cross"
        ma_long_pure := ma_fast_cross_slow_up
        ma_short_pure := ma_fast_cross_slow_down
    else if ma_signal_type == "Direction"
        ma_long_pure := ma_fast_calc > ma_fast_calc[1] and ma_slow_calc > ma_slow_calc[1]
        ma_short_pure := ma_fast_calc < ma_fast_calc[1] and ma_slow_calc < ma_slow_calc[1]
    else if ma_signal_type == "Opposite Trend"
        ma_long_pure := ma_fast_calc < ma_slow_calc and close < ma_slow_calc
        ma_short_pure := ma_fast_calc > ma_slow_calc and close > ma_slow_calc
    
    // Update signal memory
    if ma_long_pure
        ma_long_signal_bar := bar_index
    if ma_short_pure
        ma_short_signal_bar := bar_index
    
    // Final signals
    ma_long_final = ma_long_pure or (ma_use_signal_memory and bar_index - ma_long_signal_bar <= ma_memory_bars)
    ma_short_final = ma_short_pure or (ma_use_signal_memory and bar_index - ma_short_signal_bar <= ma_memory_bars)
    
    if ma_long_final
        met_conditions_long += 1
    if ma_short_final
        met_conditions_short += 1

// Channels Signals with Memory
if use_channels
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    channel_long_pure = false
    channel_short_pure = false
    
    if channel_signal_type == "Rebound"
        channel_long_pure := low <= channel_lower and close > channel_lower
        channel_short_pure := high >= channel_upper and close < channel_upper
    else if channel_signal_type == "Breakout"
        channel_long_pure := close > channel_upper
        channel_short_pure := close < channel_lower
    
    // Update signal memory
    if channel_long_pure
        channel_long_signal_bar := bar_index
    if channel_short_pure
        channel_short_signal_bar := bar_index
    
    // Final signals
    channel_long_final = channel_long_pure or (channel_use_signal_memory and bar_index - channel_long_signal_bar <= channel_memory_bars)
    channel_short_final = channel_short_pure or (channel_use_signal_memory and bar_index - channel_short_signal_bar <= channel_memory_bars)
    
    if channel_long_final
        met_conditions_long += 1
    if channel_short_final
        met_conditions_short += 1

// Stochastic Signals with Memory
if use_stochastic
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    stoch_long_pure = false
    stoch_short_pure = false
    
    if stoch_signal_type == "Oversold Cross"
        stoch_long_pure := stoch_cross_oversold_up
        stoch_short_pure := stoch_cross_overbought_down
    else if stoch_signal_type == "Overbought Cross"
        stoch_long_pure := stoch_cross_overbought_down_2
        stoch_short_pure := stoch_cross_oversold_up_2
    else if stoch_signal_type == "K-D Cross"
        stoch_long_pure := stoch_k_cross_d_up
        stoch_short_pure := stoch_k_cross_d_down
    
    // Update signal memory
    if stoch_long_pure
        stoch_long_signal_bar := bar_index
    if stoch_short_pure
        stoch_short_signal_bar := bar_index
    
    // Final signals
    stoch_long_final = stoch_long_pure or (stoch_use_signal_memory and bar_index - stoch_long_signal_bar <= stoch_memory_bars)
    stoch_short_final = stoch_short_pure or (stoch_use_signal_memory and bar_index - stoch_short_signal_bar <= stoch_memory_bars)
    
    if stoch_long_final
        met_conditions_long += 1
    if stoch_short_final
        met_conditions_short += 1

// MFI Signals with Memory
if use_mfi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    mfi_long_pure = mfi_calc <= mfi_oversold
    mfi_short_pure = mfi_calc >= mfi_overbought
    
    // Update signal memory
    if mfi_long_pure
        mfi_long_signal_bar := bar_index
    if mfi_short_pure
        mfi_short_signal_bar := bar_index
    
    // Final signals
    mfi_long_final = mfi_long_pure or (mfi_use_signal_memory and bar_index - mfi_long_signal_bar <= mfi_memory_bars)
    mfi_short_final = mfi_short_pure or (mfi_use_signal_memory and bar_index - mfi_short_signal_bar <= mfi_memory_bars)
    
    if mfi_long_final
        met_conditions_long += 1
    if mfi_short_final
        met_conditions_short += 1

// CCI Signals with Memory
if use_cci
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    cci_long_pure = cci_calc <= cci_oversold
    cci_short_pure = cci_calc >= cci_overbought
    
    // Update signal memory
    if cci_long_pure
        cci_long_signal_bar := bar_index
    if cci_short_pure
        cci_short_signal_bar := bar_index
    
    // Final signals
    cci_long_final = cci_long_pure or (cci_use_signal_memory and bar_index - cci_long_signal_bar <= cci_memory_bars)
    cci_short_final = cci_short_pure or (cci_use_signal_memory and bar_index - cci_short_signal_bar <= cci_memory_bars)
    
    if cci_long_final
        met_conditions_long += 1
    if cci_short_final
        met_conditions_short += 1

// MACD Signals with Memory
if use_macd
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    macd_long_pure = false
    macd_short_pure = false
    
    if macd_condition == "Signal Cross"
        macd_long_pure := macd_cross_signal_up
        macd_short_pure := macd_cross_signal_down
    else if macd_condition == "Zero Cross"
        macd_long_pure := macd_cross_zero_up
        macd_short_pure := macd_cross_zero_down
    
    // Update signal memory
    if macd_long_pure
        macd_long_signal_bar := bar_index
    if macd_short_pure
        macd_short_signal_bar := bar_index
    
    // Final signals
    macd_long_final = macd_long_pure or (macd_use_signal_memory and bar_index - macd_long_signal_bar <= macd_memory_bars)
    macd_short_final = macd_short_pure or (macd_use_signal_memory and bar_index - macd_short_signal_bar <= macd_memory_bars)
    
    if macd_long_final
        met_conditions_long += 1
    if macd_short_final
        met_conditions_short += 1

// Highest/Lowest Bar Signals with Memory
if use_highlow
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    highlow_long_pure = high == ta.highest(high, highlow_period)
    highlow_short_pure = low == ta.lowest(low, highlow_period)
    
    // Update signal memory
    if highlow_long_pure
        highlow_long_signal_bar := bar_index
    if highlow_short_pure
        highlow_short_signal_bar := bar_index
    
    // Final signals
    highlow_long_final = highlow_long_pure or (highlow_use_signal_memory and bar_index - highlow_long_signal_bar <= highlow_memory_bars)
    highlow_short_final = highlow_short_pure or (highlow_use_signal_memory and bar_index - highlow_short_signal_bar <= highlow_memory_bars)
    
    if highlow_long_final
        met_conditions_long += 1
    if highlow_short_final
        met_conditions_short += 1

// Accumulation Areas Signals with Memory
if use_accumulation
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    highest_acc = ta.highest(high, accumulation_length)
    lowest_acc = ta.lowest(low, accumulation_length)
    range_acc = (highest_acc - lowest_acc) / lowest_acc * 100
    in_accumulation = range_acc <= accumulation_range
    
    accumulation_long_pure = in_accumulation and close > ta.sma(close, accumulation_length)
    accumulation_short_pure = in_accumulation and close < ta.sma(close, accumulation_length)
    
    // Update signal memory
    if accumulation_long_pure
        accumulation_long_signal_bar := bar_index
    if accumulation_short_pure
        accumulation_short_signal_bar := bar_index
    
    // Final signals
    accumulation_long_final = accumulation_long_pure or (accumulation_use_signal_memory and bar_index - accumulation_long_signal_bar <= accumulation_memory_bars)
    accumulation_short_final = accumulation_short_pure or (accumulation_use_signal_memory and bar_index - accumulation_short_signal_bar <= accumulation_memory_bars)
    
    if accumulation_long_final
        met_conditions_long += 1
    if accumulation_short_final
        met_conditions_short += 1

// Pin Bar + MA Signals with Memory
if use_pinbar_ma
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    ma_pinbar = ta.sma(close, pinbar_ma_length)
    pinbar_long_pure = pin_long and close > ma_pinbar and low < ma_pinbar
    pinbar_short_pure = pin_short and close < ma_pinbar and high > ma_pinbar
    
    // Update signal memory
    if pinbar_long_pure
        pinbar_ma_long_signal_bar := bar_index
    if pinbar_short_pure
        pinbar_ma_short_signal_bar := bar_index
    
    // Final signals
    pinbar_long_final = pinbar_long_pure or (pinbar_ma_use_signal_memory and bar_index - pinbar_ma_long_signal_bar <= pinbar_ma_memory_bars)
    pinbar_short_final = pinbar_short_pure or (pinbar_ma_use_signal_memory and bar_index - pinbar_ma_short_signal_bar <= pinbar_ma_memory_bars)
    
    if pinbar_long_final
        met_conditions_long += 1
    if pinbar_short_final
        met_conditions_short += 1

// RVI Signals with Memory
if use_rvi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    rvi_long_pure = rvi_value <= rvi_oversold
    rvi_short_pure = rvi_value >= rvi_overbought
    
    // Update signal memory
    if rvi_long_pure
        rvi_long_signal_bar := bar_index
    if rvi_short_pure
        rvi_short_signal_bar := bar_index
    
    // Final signals
    rvi_long_final = rvi_long_pure or (rvi_use_signal_memory and bar_index - rvi_long_signal_bar <= rvi_memory_bars)
    rvi_short_final = rvi_short_pure or (rvi_use_signal_memory and bar_index - rvi_short_signal_bar <= rvi_memory_bars)
    
    if rvi_long_final
        met_conditions_long += 1
    if rvi_short_final
        met_conditions_short += 1

// Momentum Signals with Memory
if use_momentum
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    momentum_long_pure = momentum_calc > momentum_overbought
    momentum_short_pure = momentum_calc < momentum_oversold
    
    // Update signal memory
    if momentum_long_pure
        momentum_long_signal_bar := bar_index
    if momentum_short_pure
        momentum_short_signal_bar := bar_index
    
    // Final signals
    momentum_long_final = momentum_long_pure or (momentum_use_signal_memory and bar_index - momentum_long_signal_bar <= momentum_memory_bars)
    momentum_short_final = momentum_short_pure or (momentum_use_signal_memory and bar_index - momentum_short_signal_bar <= momentum_memory_bars)
    
    if momentum_long_final
        met_conditions_long += 1
    if momentum_short_final
        met_conditions_short += 1

// SMI Signals with Memory
if use_smi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    smi_long_pure = smi_value <= smi_oversold
    smi_short_pure = smi_value >= smi_overbought
    
    // Update signal memory
    if smi_long_pure
        smi_long_signal_bar := bar_index
    if smi_short_pure
        smi_short_signal_bar := bar_index
    
    // Final signals
    smi_long_final = smi_long_pure or (smi_use_signal_memory and bar_index - smi_long_signal_bar <= smi_memory_bars)
    smi_short_final = smi_short_pure or (smi_use_signal_memory and bar_index - smi_short_signal_bar <= smi_memory_bars)
    
    if smi_long_final
        met_conditions_long += 1
    if smi_short_final
        met_conditions_short += 1

// DMI Signals with Memory
if use_dmi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    dmi_long_pure = di_plus > di_minus and adx > dmi_adx_threshold
    dmi_short_pure = di_minus > di_plus and adx > dmi_adx_threshold
    
    // Update signal memory
    if dmi_long_pure
        dmi_long_signal_bar := bar_index
    if dmi_short_pure
        dmi_short_signal_bar := bar_index
    
    // Final signals
    dmi_long_final = dmi_long_pure or (dmi_use_signal_memory and bar_index - dmi_long_signal_bar <= dmi_memory_bars)
    dmi_short_final = dmi_short_pure or (dmi_use_signal_memory and bar_index - dmi_short_signal_bar <= dmi_memory_bars)
    
    if dmi_long_final
        met_conditions_long += 1
    if dmi_short_final
        met_conditions_short += 1

// CMF Signals with Memory
if use_cmf
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    cmf_long_pure = cmf_value <= cmf_oversold or cmf_cross_zero_up
    cmf_short_pure = cmf_value >= cmf_overbought or cmf_cross_zero_down
    
    // Update signal memory
    if cmf_long_pure
        cmf_long_signal_bar := bar_index
    if cmf_short_pure
        cmf_short_signal_bar := bar_index
    
    // Final signals
    cmf_long_final = cmf_long_pure or (cmf_use_signal_memory and bar_index - cmf_long_signal_bar <= cmf_memory_bars)
    cmf_short_final = cmf_short_pure or (cmf_use_signal_memory and bar_index - cmf_short_signal_bar <= cmf_memory_bars)
    
    if cmf_long_final
        met_conditions_long += 1
    if cmf_short_final
        met_conditions_short += 1

// BOP Signals with Memory
if use_bop
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    bop_long_pure = bop_value <= bop_oversold or bop_cross_zero_up
    bop_short_pure = bop_value >= bop_overbought or bop_cross_zero_down
    
    // Update signal memory
    if bop_long_pure
        bop_long_signal_bar := bar_index
    if bop_short_pure
        bop_short_signal_bar := bar_index
    
    // Final signals
    bop_long_final = bop_long_pure or (bop_use_signal_memory and bar_index - bop_long_signal_bar <= bop_memory_bars)
    bop_short_final = bop_short_pure or (bop_use_signal_memory and bar_index - bop_short_signal_bar <= bop_memory_bars)
    
    if bop_long_final
        met_conditions_long += 1
    if bop_short_final
        met_conditions_short += 1

// QQE Signals with Memory
if use_qqe
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    qqe_long_pure = qqe_trend == 1 and qqe_trend[1] == -1
    qqe_short_pure = qqe_trend == -1 and qqe_trend[1] == 1
    
    // Update signal memory
    if qqe_long_pure
        qqe_long_signal_bar := bar_index
    if qqe_short_pure
        qqe_short_signal_bar := bar_index
    
    // Final signals
    qqe_long_final = qqe_long_pure or (qqe_use_signal_memory and bar_index - qqe_long_signal_bar <= qqe_memory_bars)
    qqe_short_final = qqe_short_pure or (qqe_use_signal_memory and bar_index - qqe_short_signal_bar <= qqe_memory_bars)
    
    if qqe_long_final
        met_conditions_long += 1
    if qqe_short_final
        met_conditions_short += 1

// Dynamic RSI Signals with Memory
if use_dynamic_rsi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    dynamic_rsi_long_pure = d_rsi <= d_rsi_lower
    dynamic_rsi_short_pure = d_rsi >= d_rsi_upper
    
    // Update signal memory
    if dynamic_rsi_long_pure
        dynamic_rsi_long_signal_bar := bar_index
    if dynamic_rsi_short_pure
        dynamic_rsi_short_signal_bar := bar_index
    
    // Final signals
    dynamic_rsi_long_final = dynamic_rsi_long_pure or (dynamic_rsi_use_signal_memory and bar_index - dynamic_rsi_long_signal_bar <= dynamic_rsi_memory_bars)
    dynamic_rsi_short_final = dynamic_rsi_short_pure or (dynamic_rsi_use_signal_memory and bar_index - dynamic_rsi_short_signal_bar <= dynamic_rsi_memory_bars)
    
    if dynamic_rsi_long_final
        met_conditions_long += 1
    if dynamic_rsi_short_final
        met_conditions_short += 1

// Dynamic MFI Signals with Memory
if use_dynamic_mfi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    dynamic_mfi_long_pure = d_mfi <= d_mfi_lower
    dynamic_mfi_short_pure = d_mfi >= d_mfi_upper
    
    // Update signal memory
    if dynamic_mfi_long_pure
        dynamic_mfi_long_signal_bar := bar_index
    if dynamic_mfi_short_pure
        dynamic_mfi_short_signal_bar := bar_index
    
    // Final signals
    dynamic_mfi_long_final = dynamic_mfi_long_pure or (dynamic_mfi_use_signal_memory and bar_index - dynamic_mfi_long_signal_bar <= dynamic_mfi_memory_bars)
    dynamic_mfi_short_final = dynamic_mfi_short_pure or (dynamic_mfi_use_signal_memory and bar_index - dynamic_mfi_short_signal_bar <= dynamic_mfi_memory_bars)
    
    if dynamic_mfi_long_final
        met_conditions_long += 1
    if dynamic_mfi_short_final
        met_conditions_short += 1

// Levels Signals with Memory
if use_levels
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    distance_to_low = math.abs(close - levels_low) / close * 100
    distance_to_high = math.abs(close - levels_high) / close * 100
    
    levels_long_pure = distance_to_low <= levels_distance
    levels_short_pure = distance_to_high <= levels_distance
    
    // Update signal memory
    if levels_long_pure
        levels_long_signal_bar := bar_index
    if levels_short_pure
        levels_short_signal_bar := bar_index
    
    // Final signals
    levels_long_final = levels_long_pure or (levels_use_signal_memory and bar_index - levels_long_signal_bar <= levels_memory_bars)
    levels_short_final = levels_short_pure or (levels_use_signal_memory and bar_index - levels_short_signal_bar <= levels_memory_bars)
    
    if levels_long_final
        met_conditions_long += 1
    if levels_short_final
        met_conditions_short += 1

// Divergences Signals with Memory
if use_divergences
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Update signal memory
    if bullish_div
        div_long_signal_bar := bar_index
    if bearish_div
        div_short_signal_bar := bar_index
    
    // Final signals
    div_long_final = bullish_div or (div_use_signal_memory and bar_index - div_long_signal_bar <= div_memory_bars)
    div_short_final = bearish_div or (div_use_signal_memory and bar_index - div_short_signal_bar <= div_memory_bars)
    
    if div_long_final
        met_conditions_long += 1
    if div_short_final
        met_conditions_short += 1

// Candle Patterns Signals with Memory
if use_candle_patterns
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Update signal memory
    if candle_bull
        candle_long_signal_bar := bar_index
    if candle_bear
        candle_short_signal_bar := bar_index
    
    // Final signals
    candle_long_final = candle_bull or (candle_use_signal_memory and bar_index - candle_long_signal_bar <= candle_memory_bars)
    candle_short_final = candle_bear or (candle_use_signal_memory and bar_index - candle_short_signal_bar <= candle_memory_bars)
    
    if candle_long_final
        met_conditions_long += 1
    if candle_short_final
        met_conditions_short += 1

// Linear Regression Channel Signals with Memory
if use_lrc
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    lrc_long_pure = close > lrc_upper
    lrc_short_pure = close < lrc_lower
    
    // Update signal memory
    if lrc_long_pure
        lrc_long_signal_bar := bar_index
    if lrc_short_pure
        lrc_short_signal_bar := bar_index
    
    // Final signals
    lrc_long_final = lrc_long_pure or (lrc_use_signal_memory and bar_index - lrc_long_signal_bar <= lrc_memory_bars)
    lrc_short_final = lrc_short_pure or (lrc_use_signal_memory and bar_index - lrc_short_signal_bar <= lrc_memory_bars)
    
    if lrc_long_final
        met_conditions_long += 1
    if lrc_short_final
        met_conditions_short += 1

// External Indicator #1 Signals with Memory
if use_external1
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    external1_long_pure = false
    external1_short_pure = false
    
    if external1_condition == "Above Zero"
        external1_long_pure := external1_source > 0
        external1_short_pure := external1_source < 0
    else if external1_condition == "Below Zero"
        external1_long_pure := external1_source < 0
        external1_short_pure := external1_source > 0
    else if external1_condition == "Cross Up"
        external1_long_pure := external1_cross_zero_up
        external1_short_pure := external1_cross_zero_down
    else if external1_condition == "Cross Down"
        external1_long_pure := external1_cross_zero_down
        external1_short_pure := external1_cross_zero_up
    
    // Update signal memory
    if external1_long_pure
        external1_long_signal_bar := bar_index
    if external1_short_pure
        external1_short_signal_bar := bar_index
    
    // Final signals
    external1_long_final = external1_long_pure or (external1_use_signal_memory and bar_index - external1_long_signal_bar <= external1_memory_bars)
    external1_short_final = external1_short_pure or (external1_use_signal_memory and bar_index - external1_short_signal_bar <= external1_memory_bars)
    
    if external1_long_final
        met_conditions_long += 1
    if external1_short_final
        met_conditions_short += 1

// External Indicator #2 Signals with Memory
if use_external2
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    external2_long_pure = false
    external2_short_pure = false
    
    if external2_condition == "Above Zero"
        external2_long_pure := external2_source > 0
        external2_short_pure := external2_source < 0
    else if external2_condition == "Below Zero"
        external2_long_pure := external2_source < 0
        external2_short_pure := external2_source > 0
    else if external2_condition == "Cross Up"
        external2_long_pure := external2_cross_zero_up
        external2_short_pure := external2_cross_zero_down
    else if external2_condition == "Cross Down"
        external2_long_pure := external2_cross_zero_down
        external2_short_pure := external2_cross_zero_up
    
    // Update signal memory
    if external2_long_pure
        external2_long_signal_bar := bar_index
    if external2_short_pure
        external2_short_signal_bar := bar_index
    
    // Final signals
    external2_long_final = external2_long_pure or (external2_use_signal_memory and bar_index - external2_long_signal_bar <= external2_memory_bars)
    external2_short_final = external2_short_pure or (external2_use_signal_memory and bar_index - external2_short_signal_bar <= external2_memory_bars)
    
    if external2_long_final
        met_conditions_long += 1
    if external2_short_final
        met_conditions_short += 1

// ===============================
// FILTERS
// ===============================

// Volume Filter
volume_filter_passed = true
if use_volume_filter
    volume_filter_passed := volume > volume_avg * volume_multiplier

// Volatility Filter
volatility_filter_passed = true
if use_volatility_filter
    volatility_filter_passed := volatility_calc > volatility_threshold

// Price Movement Filter
price_filter_passed = true
if use_price_filter
    price_filter_passed := price_change >= price_min_change

// ATR Growth Filter
atr_growth_filter_passed = true
if use_atr_growth_filter
    atr_growth_filter_passed := atr_growth >= atr_growth_multiplier

// Block if Worse Than Filter
block_worse_filter_passed = true
if use_block_worse
    block_worse_filter_passed := price_move_current_bar <= block_worse_percent

// SuperTrend Trend Filter
st_trend_filter_passed = true
if use_st_trend_filter
    st_trend_filter_passed := st_trend_direction == 1 // Allow both directions, modify as needed

// Combine all filters
all_filters_passed = volume_filter_passed and volatility_filter_passed and price_filter_passed and atr_growth_filter_passed and block_worse_filter_passed and st_trend_filter_passed

// ===============================
// ENTRY CONDITIONS
// ===============================

// Entry cooldown
can_enter = bar_index - last_entry_bar_index >= entry_cooldown_bars

// Final entry conditions
entry_conditions_met_long = (active_conditions_long > 0 and met_conditions_long == active_conditions_long) or (active_conditions_long == 0 and allow_entry_without_indicators)
entry_conditions_met_short = (active_conditions_short > 0 and met_conditions_short == active_conditions_short) or (active_conditions_short == 0 and allow_entry_without_indicators)

final_long_signal = use_long_trades and time_trade_allowed and entry_conditions_met_long and all_filters_passed and strategy.position_size == 0 and can_enter and barstate.isconfirmed
final_short_signal = use_short_trades and time_trade_allowed and entry_conditions_met_short and all_filters_passed and strategy.position_size == 0 and can_enter and barstate.isconfirmed

// ===============================
// STRATEGY EXECUTION
// ===============================

// Order Indent Logic - ИСПРАВЛЕННАЯ ВЕРСИЯ
if use_order_indent and (final_long_signal or final_short_signal) and strategy.position_size == 0
    if final_long_signal
        indent_target_price := close * (1 - indent_percent / 100)
        waiting_for_long_indent := true
        waiting_for_short_indent := false
    else
        indent_target_price := close * (1 + indent_percent / 100)
        waiting_for_short_indent := true
        waiting_for_long_indent := false
    indent_bar_counter := 0

// Cancel indent orders if time expires
if not na(indent_target_price)
    indent_bar_counter += 1
    if indent_bar_counter > indent_cancel_bars
        indent_target_price := na
        indent_bar_counter := 0
        waiting_for_long_indent := false
        waiting_for_short_indent := false

// Execute Orders - ИСПРАВЛЕННАЯ ВЕРСИЯ
if final_long_signal and strategy.position_size == 0 and not use_order_indent
    strategy.entry("Long", strategy.long)
    last_entry_bar_index := bar_index

if final_short_signal and strategy.position_size == 0 and not use_order_indent
    strategy.entry("Short", strategy.short)
    last_entry_bar_index := bar_index

// Execute indent orders - ИСПРАВЛЕННАЯ ВЕРСИЯ
if not na(indent_target_price) and strategy.position_size == 0
    if waiting_for_long_indent and close <= indent_target_price
        strategy.entry("Long", strategy.long)
        last_entry_bar_index := bar_index
        indent_target_price := na
        indent_bar_counter := 0
        waiting_for_long_indent := false
    
    if waiting_for_short_indent and close >= indent_target_price
        strategy.entry("Short", strategy.short)
        last_entry_bar_index := bar_index
        indent_target_price := na
        indent_bar_counter := 0
        waiting_for_short_indent := false

// ===============================
// EXIT MANAGEMENT
// ===============================

// Calculate TP/SL levels
sl_percent_final = sl_equals_tp ? take_profit_percent : stop_loss_percent
avg_price = strategy.position_avg_price

// Breakeven Logic - ИСПРАВЛЕННАЯ ВЕРСИЯ
if use_breakeven and strategy.position_size != 0 and not breakeven_activated
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= breakeven_activation
        breakeven_activated := true

// Trailing Stop Logic - ИСПРАВЛЕННАЯ ВЕРСИЯ
if use_trailing_stop and strategy.position_size != 0
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= trailing_activation
        if strategy.position_size > 0
            new_trailing_level = close * (1 - trailing_distance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.max(trailing_stop_level, new_trailing_level)
        else
            new_trailing_level = close * (1 + trailing_distance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.min(trailing_stop_level, new_trailing_level)

// TP/SL Execution - ИСПРАВЛЕННАЯ ВЕРСИЯ
if strategy.position_size != 0
    tp_level = 0.0
    sl_level = 0.0
    
    if strategy.position_size > 0
        // Long position
        tp_level := use_atr_take_profit ? avg_price + atr_tp_val * atr_tp_multiplier : avg_price * (1 + take_profit_percent / 100)
        sl_level := use_atr_stop_loss ? avg_price - atr_sl_val * atr_sl_multiplier : avg_price * (1 - sl_percent_final / 100)
        
        // Apply breakeven
        if use_breakeven and breakeven_activated
            breakeven_sl_level = avg_price * (1 + breakeven_level / 100)
            sl_level := math.max(sl_level, breakeven_sl_level)
        
        // Apply trailing stop
        if use_trailing_stop and not na(trailing_stop_level)
            sl_level := math.max(sl_level, trailing_stop_level)
        
        // Multi TP or regular exit
        if use_multi_tp and not tp1_executed and not tp2_executed and not tp3_executed
            // Reset Multi TP flags when new position opens
            if strategy.position_size != strategy.position_size[1]
                tp1_executed := false
                tp2_executed := false
                tp3_executed := false
            
            total_qty = math.abs(strategy.position_size)
            tp1_price = avg_price * (1 + tp1_percent / 100)
            tp2_price = avg_price * (1 + tp2_percent / 100)
            tp3_price = avg_price * (1 + tp3_percent / 100)
            
            tp1_qty_calc = total_qty * tp1_qty / 100
            tp2_qty_calc = total_qty * tp2_qty / 100
            tp3_qty_calc = total_qty * tp3_qty / 100
            remaining_qty = total_qty - tp1_qty_calc - tp2_qty_calc - tp3_qty_calc
            
            if not tp1_executed and close >= tp1_price
                strategy.close("Long", qty=tp1_qty_calc, comment="TP1")
                tp1_executed := true
            if not tp2_executed and close >= tp2_price
                strategy.close("Long", qty=tp2_qty_calc, comment="TP2") 
                tp2_executed := true
            if not tp3_executed and close >= tp3_price
                strategy.close("Long", qty=tp3_qty_calc, comment="TP3")
                tp3_executed := true
            if close >= tp_level
                strategy.close("Long", qty=remaining_qty, comment="TP4")
            if close <= sl_level
                strategy.close_all(comment="SL")
        else
            strategy.exit("Exit", limit=tp_level, stop=sl_level)
    
    else
        // Short position
        tp_level := use_atr_take_profit ? avg_price - atr_tp_val * atr_tp_multiplier : avg_price * (1 - take_profit_percent / 100)
        sl_level := use_atr_stop_loss ? avg_price + atr_sl_val * atr_sl_multiplier : avg_price * (1 + sl_percent_final / 100)
        
        // Apply breakeven
        if use_breakeven and breakeven_activated
            breakeven_sl_level = avg_price * (1 - breakeven_level / 100)
            sl_level := math.min(sl_level, breakeven_sl_level)
        
        // Apply trailing stop
        if use_trailing_stop and not na(trailing_stop_level)
            sl_level := math.min(sl_level, trailing_stop_level)
        
        // Multi TP or regular exit
        if use_multi_tp and not tp1_executed and not tp2_executed and not tp3_executed
            // Reset Multi TP flags when new position opens
            if strategy.position_size != strategy.position_size[1]
                tp1_executed := false
                tp2_executed := false
                tp3_executed := false
            
            total_qty = math.abs(strategy.position_size)
            tp1_price = avg_price * (1 - tp1_percent / 100)
            tp2_price = avg_price * (1 - tp2_percent / 100)
            tp3_price = avg_price * (1 - tp3_percent / 100)
            
            tp1_qty_calc = total_qty * tp1_qty / 100
            tp2_qty_calc = total_qty * tp2_qty / 100
            tp3_qty_calc = total_qty * tp3_qty / 100
            remaining_qty = total_qty - tp1_qty_calc - tp2_qty_calc - tp3_qty_calc
            
            if not tp1_executed and close <= tp1_price
                strategy.close("Short", qty=tp1_qty_calc, comment="TP1")
                tp1_executed := true
            if not tp2_executed and close <= tp2_price
                strategy.close("Short", qty=tp2_qty_calc, comment="TP2")
                tp2_executed := true
            if not tp3_executed and close <= tp3_price
                strategy.close("Short", qty=tp3_qty_calc, comment="TP3")
                tp3_executed := true
            if close <= tp_level
                strategy.close("Short", qty=remaining_qty, comment="TP4")
            if close >= sl_level
                strategy.close_all(comment="SL")
        else
            strategy.exit("Exit", limit=tp_level, stop=sl_level)

// ===============================
// CLOSE CONDITIONS
// ===============================

// Check profit condition for close signals
profit_check_passed = true
if close_only_profit and strategy.position_size != 0
    profit_check_passed := strategy.openprofit >= avg_price * min_profit_percent / 100

// RSI Close
if close_by_rsi and strategy.position_size != 0 and use_rsi and profit_check_passed
    rsi_close_condition = (strategy.position_size > 0 and rsi_calc > rsi_overbought) or (strategy.position_size < 0 and rsi_calc < rsi_oversold)
    if rsi_close_condition
        strategy.close_all(comment="RSI Close")

// Channel Close
if close_by_channel and strategy.position_size != 0 and use_channels and profit_check_passed
    channel_close_condition = (strategy.position_size > 0 and close > channel_upper) or (strategy.position_size < 0 and close < channel_lower)
    if channel_close_condition
        strategy.close_all(comment="Channel Close")

// MA Cross Close
if close_by_ma_cross and strategy.position_size != 0 and use_ma and profit_check_passed
    ma_close_condition = (strategy.position_size > 0 and ma_fast_cross_slow_down) or (strategy.position_size < 0 and ma_fast_cross_slow_up)
    if ma_close_condition
        strategy.close_all(comment="MA Close")

// QQE Close
if close_by_qqe and strategy.position_size != 0 and use_qqe and profit_check_passed
    qqe_close_condition = (strategy.position_size > 0 and qqe_trend == -1) or (strategy.position_size < 0 and qqe_trend == 1)
    if qqe_close_condition
        strategy.close_all(comment="QQE Close")

// Linear Regression Channel Close
if close_by_lrc and strategy.position_size != 0 and use_lrc and profit_check_passed
    lrc_close_condition = (strategy.position_size > 0 and close > lrc_upper) or (strategy.position_size < 0 and close < lrc_lower)
    if lrc_close_condition
        strategy.close_all(comment="LRC Close")

// Levels Close
if close_by_levels and strategy.position_size != 0 and use_levels and profit_check_passed
    distance_to_opposite_level = strategy.position_size > 0 ? math.abs(close - levels_high) / close * 100 : math.abs(close - levels_low) / close * 100
    levels_close_condition = distance_to_opposite_level <= levels_distance
    if levels_close_condition
        strategy.close_all(comment="Levels Close")

// Pyramiding Logic - ИСПРАВЛЕННАЯ ВЕРСИЯ
if use_pyramiding and strategy.position_size != 0
    price_move = 0.0
    if strategy.position_size > 0
        price_move := (close - avg_price) / avg_price * 100
    else
        price_move := (avg_price - close) / avg_price * 100
    
    if price_move >= pyramid_min_move
        if strategy.position_size > 0 and final_long_signal
            strategy.entry("Pyramid L", strategy.long)
        if strategy.position_size < 0 and final_short_signal
            strategy.entry("Pyramid S", strategy.short)

// Reverse Orders Logic - ИСПРАВЛЕННАЯ ВЕРСИЯ
if use_reverse_order_on_sl and strategy.closedtrades > 0
    last_trade = strategy.closedtrades - 1
    last_profit = strategy.closedtrades.profit(last_trade)
    
    if last_profit < 0 and barstate.isconfirmed and strategy.position_size == 0 and strategy.position_size[1] != 0
        last_size = strategy.closedtrades.size(last_trade)
        reverse_qty = math.abs(last_size) * reverse_qty_percent / 100
        
        if last_size > 0
            strategy.entry("Rev S", strategy.short, qty=reverse_qty)
        else
            strategy.entry("Rev L", strategy.long, qty=reverse_qty)

if use_reverse_order_on_be and strategy.closedtrades > 0 and breakeven_activated
    last_trade = strategy.closedtrades - 1
    last_profit = strategy.closedtrades.profit(last_trade)
    
    if last_profit >= 0 and last_profit <= avg_price * breakeven_level / 100 and barstate.isconfirmed and strategy.position_size == 0 and strategy.position_size[1] != 0
        last_size = strategy.closedtrades.size(last_trade)
        reverse_qty = math.abs(last_size) * reverse_qty_percent / 100
        
        if last_size > 0
            strategy.entry("Rev BE S", strategy.short, qty=reverse_qty)
        else
            strategy.entry("Rev BE L", strategy.long, qty=reverse_qty)

// Reset variables when position closes
if strategy.position_size == 0 and strategy.position_size[1] != 0
    trailing_stop_level := na
    breakeven_activated := false
    tp1_executed := false
    tp2_executed := false
    tp3_executed := false
    waiting_for_long_indent := false
    waiting_for_short_indent := false

// ===============================
// VISUALIZATION
// ===============================

// Plot indicators
plot(use_ma ? ma_fast_calc : na, "Fast MA", color=color.blue, linewidth=1)
plot(use_ma ? ma_slow_calc : na, "Slow MA", color=color.red, linewidth=1)
plot(use_supertrend ? st_line : na, "SuperTrend", color=st_direction == 1 ? color.green : color.red, linewidth=2)
plot(use_supertrend2 ? st2_line : na, "SuperTrend #2", color=st2_direction == 1 ? color.lime : color.maroon, linewidth=1)

// Plot channels
plot(use_channels ? channel_upper : na, "Channel Upper", color=color.purple)
plot(use_channels ? channel_basis : na, "Channel Basis", color=color.gray)
plot(use_channels ? channel_lower : na, "Channel Lower", color=color.purple)

// Plot Linear Regression Channel
plot(use_lrc ? lrc_upper : na, "LRC Upper", color=color.orange)
plot(use_lrc ? lrc_mid : na, "LRC Mid", color=color.yellow)
plot(use_lrc ? lrc_lower : na, "LRC Lower", color=color.orange)

// Plot Levels
hline(use_levels ? levels_high : na, "High Level", color=color.red, linestyle=hline.style_dashed)
hline(use_levels ? levels_low : na, "Low Level", color=color.green, linestyle=hline.style_dashed)

// Plot SuperTrend Trend Filter
plot(use_st_trend_filter ? st_trend_line : na, "ST Trend Filter", color=st_trend_direction == 1 ? color.aqua : color.fuchsia, linewidth=1)

// Signal visualization
if show_entry_signals and (show_all_signals or strategy.position_size == 0)
    if final_long_signal
        label.new(bar_index, low - atr_14, "LONG\n" + str.tostring(met_conditions_long) + "/" + str.tostring(active_conditions_long), 
                  color=color.green, style=label.style_label_up, textcolor=color.white, size=size.normal)
    
    if final_short_signal
        label.new(bar_index, high + atr_14, "SHORT\n" + str.tostring(met_conditions_short) + "/" + str.tostring(active_conditions_short), 
                  color=color.red, style=label.style_label_down, textcolor=color.white, size=size.normal)

// Plot divergences
plotshape(use_divergences and bullish_div, title="Bullish Div", location=location.belowbar, color=color.green, style=shape.labelup, text="BD", size=size.tiny)
plotshape(use_divergences and bearish_div, title="Bearish Div", location=location.abovebar, color=color.red, style=shape.labeldown, text="BD", size=size.tiny)

// Plot candle patterns
plotshape(use_candle_patterns and candle_bull, title="Bull Pattern", location=location.belowbar, color=color.lime, style=shape.triangleup, size=size.small)
plotshape(use_candle_patterns and candle_bear, title="Bear Pattern", location=location.abovebar, color=color.maroon, style=shape.triangledown, size=size.small)

// Background color for QQE trend
bgcolor(use_qqe and show_entry_signals ? (qqe_trend == 1 ? color.new(color.green, 95) : qqe_trend == -1 ? color.new(color.red, 95) : na) : na, title="QQE Trend BG")

// ===============================
// INFORMATION TABLE
// ===============================

if barstate.islast
    var table info_table = table.new(position.top_right, 3, 12, bgcolor=color.new(color.black, 90), border_width=1)
    
    table.cell(info_table, 0, 0, "Multi Scalping Status", bgcolor=color.blue, text_color=color.white)
    table.cell(info_table, 1, 0, "Long", bgcolor=color.blue, text_color=color.white)
    table.cell(info_table, 2, 0, "Short", bgcolor=color.blue, text_color=color.white)
    
    table.cell(info_table, 0, 1, "Active Conditions:", text_color=color.white)
    table.cell(info_table, 1, 1, str.tostring(active_conditions_long), text_color=color.white)
    table.cell(info_table, 2, 1, str.tostring(active_conditions_short), text_color=color.white)
    
    table.cell(info_table, 0, 2, "Met Conditions:", text_color=color.white)
    table.cell(info_table, 1, 2, str.tostring(met_conditions_long), text_color=color.white)
    table.cell(info_table, 2, 2, str.tostring(met_conditions_short), text_color=color.white)
    
    table.cell(info_table, 0, 3, "Filters:", text_color=color.white)
    table.cell(info_table, 1, 3, all_filters_passed ? "✓" : "✗", text_color=all_filters_passed ? color.green : color.red)
    table.cell(info_table, 2, 3, all_filters_passed ? "✓" : "✗", text_color=all_filters_passed ? color.green : color.red)
    
    table.cell(info_table, 0, 4, "Final Signal:", text_color=color.white)
    table.cell(info_table, 1, 4, final_long_signal ? "BUY" : "-", text_color=final_long_signal ? color.green : color.gray)
    table.cell(info_table, 2, 4, final_short_signal ? "SELL" : "-", text_color=final_short_signal ? color.red : color.gray)
    
    table.cell(info_table, 0, 5, "Position:", text_color=color.white)
    table.cell(info_table, 1, 5, str.tostring(strategy.position_size), text_color=strategy.position_size == 0 ? color.green : color.yellow)
    table.cell(info_table, 2, 5, str.tostring(strategy.openprofit, "#.##") + "$", text_color=strategy.openprofit >= 0 ? color.green : color.red)
    
    table.cell(info_table, 0, 6, "Breakeven:", text_color=color.white)
    table.cell(info_table, 1, 6, breakeven_activated ? "Active" : "Inactive", text_color=breakeven_activated ? color.green : color.gray)
    table.cell(info_table, 2, 6, use_multi_tp ? (str.tostring(tp1_executed) + "/" + str.tostring(tp2_executed) + "/" + str.tostring(tp3_executed)) : "", text_color=color.white)

    table.cell(info_table, 0, 7, "Indent:", text_color=color.white)
    table.cell(info_table, 1, 7, waiting_for_long_indent ? "Wait Long" : "-", text_color=waiting_for_long_indent ? color.yellow : color.gray)
    table.cell(info_table, 2, 7, waiting_for_short_indent ? "Wait Short" : "-", text_color=waiting_for_short_indent ? color.yellow : color.gray)
    
    table.cell(info_table, 0, 8, "Volume Filter:", text_color=color.white)
    table.cell(info_table, 1, 8, volume_filter_passed ? "✓" : "✗", text_color=volume_filter_passed ? color.green : color.red)
    table.cell(info_table, 2, 8, str.tostring(volume / volume_avg, "#.##"), text_color=color.white)
    
    table.cell(info_table, 0, 9, "Volatility Filter:", text_color=color.white)
    table.cell(info_table, 1, 9, volatility_filter_passed ? "✓" : "✗", text_color=volatility_filter_passed ? color.green : color.red)
    table.cell(info_table, 2, 9, str.tostring(volatility_calc, "#.##") + "%", text_color=color.white)
    
    table.cell(info_table, 0, 10, "SuperTrend:", text_color=color.white)
    table.cell(info_table, 1, 10, st_direction == 1 ? "Bullish" : "Bearish", text_color=st_direction == 1 ? color.green : color.red)
    table.cell(info_table, 2, 10, str.tostring(st_line, "#.##"), text_color=color.white)
    
    table.cell(info_table, 0, 11, "RSI Value:", text_color=color.white)
    table.cell(info_table, 1, 11, str.tostring(rsi_calc, "#.##"), text_color=rsi_calc > 70 ? color.red : rsi_calc < 30 ? color.green : color.white)
    table.cell(info_table, 2, 11, str.tostring(mfi_calc, "#.##"), text_color=mfi_calc > 80 ? color.red : mfi_calc < 20 ? color.green : color.white)

// ===============================
// ALERTS
// ===============================
if final_long_signal
    alert_msg = '{"action": "LONG", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + ', "conditions": ' + str.tostring(met_conditions_long) + '/' + str.tostring(active_conditions_long) + '}'
    alert(alert_msg, alert.freq_once_per_bar)

if final_short_signal
    alert_msg = '{"action": "SHORT", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + ', "conditions": ' + str.tostring(met_conditions_short) + '/' + str.tostring(active_conditions_short) + '}'
    alert(alert_msg, alert.freq_once_per_bar)

if strategy.position_size[1] != 0 and strategy.position_size == 0
    alert_msg = '{"action": "CLOSE", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + '}'
    alert(alert_msg, alert.freq_once_per_bar)
