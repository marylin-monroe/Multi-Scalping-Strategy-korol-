// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © polypokrbinc
//@version=5

strategy("Multi Scalping Strategy [Dimkud Clone]", shorttitle="MSS Clone", overlay=true, pyramiding=3, default_qty_type=strategy.percent_of_equity, default_qty_value=10, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.1, calc_on_order_fills=true, calc_on_every_tick=false, max_labels_count=500, max_lines_count=500, max_bars_back=5000, process_orders_on_close=true, fill_orders_on_standard_ohlc=true)

// ===============================
// BASIC TRADING SETTINGS
// ===============================
basic_group = "═══════════ Basic Trading Settings ═══════════"
use_long_trades = input.bool(true, "Use Long Trades", group=basic_group)
use_short_trades = input.bool(true, "Use Short Trades", group=basic_group)
allow_entry_without_indicators = input.bool(false, "Allow Entry if NO Indicators Active?", group=basic_group)
entry_cooldown_bars = input.int(5, "Min Bars Between Entries", minval=0, maxval=100, group=basic_group)

// ===============================
// SIGNAL MEMORY VARIABLES
// ===============================
// Memory Length Constants
SIGNAL_MEMORY_DEFAULT = 5

// Signal Memory Variables for ALL Indicators
var int rsi_long_signal_bar = 0
var int rsi_short_signal_bar = 0
var int st_long_signal_bar = 0
var int st_short_signal_bar = 0
var int st2_long_signal_bar = 0
var int st2_short_signal_bar = 0
var int ma_long_signal_bar = 0
var int ma_short_signal_bar = 0
var int channel_long_signal_bar = 0
var int channel_short_signal_bar = 0
var int stoch_long_signal_bar = 0
var int stoch_short_signal_bar = 0
var int mfi_long_signal_bar = 0
var int mfi_short_signal_bar = 0
var int cci_long_signal_bar = 0
var int cci_short_signal_bar = 0
var int momentum_long_signal_bar = 0
var int momentum_short_signal_bar = 0
var int rvi_long_signal_bar = 0
var int rvi_short_signal_bar = 0
var int smi_long_signal_bar = 0
var int smi_short_signal_bar = 0
var int dmi_long_signal_bar = 0
var int dmi_short_signal_bar = 0
var int cmf_long_signal_bar = 0
var int cmf_short_signal_bar = 0
var int bop_long_signal_bar = 0
var int bop_short_signal_bar = 0
var int macd_long_signal_bar = 0
var int macd_short_signal_bar = 0
var int qqe_long_signal_bar = 0
var int qqe_short_signal_bar = 0
var int dynamic_rsi_long_signal_bar = 0
var int dynamic_rsi_short_signal_bar = 0
var int dynamic_mfi_long_signal_bar = 0
var int dynamic_mfi_short_signal_bar = 0
var int levels_long_signal_bar = 0
var int levels_short_signal_bar = 0
var int div_long_signal_bar = 0
var int div_short_signal_bar = 0
var int candle_long_signal_bar = 0
var int candle_short_signal_bar = 0
var int lrc_long_signal_bar = 0
var int lrc_short_signal_bar = 0
var int external1_long_signal_bar = 0
var int external1_short_signal_bar = 0
var int external2_long_signal_bar = 0
var int external2_short_signal_bar = 0
var int pinbar_ma_long_signal_bar = 0
var int pinbar_ma_short_signal_bar = 0
var int accumulation_long_signal_bar = 0
var int accumulation_short_signal_bar = 0
var int highlow_long_signal_bar = 0
var int highlow_short_signal_bar = 0

// Position management variables
var float trailing_stop_level = na
var bool breakeven_activated = false
var int last_entry_bar_index = 0

// ===============================
// HELPER FUNCTIONS
// ===============================
ma_function(src, length, ma_type) =>
    result = switch ma_type
        "SMA" => ta.sma(src, length)
        "EMA" => ta.ema(src, length)
        "RMA" => ta.rma(src, length)
        "WMA" => ta.wma(src, length)
        "HMA" => ta.hma(src, length)
        "VWMA" => ta.vwma(src, length)
        "TEMA" => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            ema3 = ta.ema(ema2, length)
            3 * (ema1 - ema2) + ema3
        "DEMA" => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            2 * ema1 - ema2
        => ta.ema(src, length)
    result

// SuperTrend Function
calculate_supertrend(src_high, src_low, src_close, factor, period, prev_direction, prev_supertrend) =>
    src_hl2 = (src_high + src_low) / 2
    atr_val = ta.atr(period)
    upperBand = src_hl2 + factor * atr_val
    lowerBand = src_hl2 - factor * atr_val
    
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])
    
    lb = lowerBand > prevLowerBand or src_close[1] < prevLowerBand ? lowerBand : prevLowerBand
    ub = upperBand < prevUpperBand or src_close[1] > prevUpperBand ? upperBand : prevUpperBand
    
    direction = 1
    superTrend = 0.0
    
    if na(prev_supertrend)
        direction := 1
        superTrend := lb
    else
        if prev_supertrend == prevUpperBand
            direction := src_close <= ub ? -1 : 1
        else
            direction := src_close >= lb ? 1 : -1
        
        superTrend := direction == -1 ? ub : lb
    
    [superTrend, direction]

// ===============================
// VISUALIZATION SETTINGS
// ===============================
viz_group = "═══════════ Visualization ═══════════"
show_tp_sl = input.bool(true, "Display TP/SL Visualization", group=viz_group)
show_entry_signals = input.bool(true, "Show Entry Signals", group=viz_group)
show_all_signals = input.bool(false, "Show All Signals (even if position open)", group=viz_group)

// ===============================
// PERIOD AND DAYS SETTINGS
// ===============================
period_group = "═══════════ Period Settings ═══════════"
start_year = input.int(2022, "Start Year", minval=2000, maxval=2100, group=period_group)
stop_year = input.int(2025, "Stop Year", minval=2000, maxval=2100, group=period_group)

days_group = "═══════════ Days To Block ═══════════"
block_sunday = input.bool(false, "Su", group=days_group, inline="days1")
block_monday = input.bool(false, "Mo", group=days_group, inline="days1") 
block_tuesday = input.bool(false, "Tu", group=days_group, inline="days1")
block_wednesday = input.bool(false, "We", group=days_group, inline="days1")
block_thursday = input.bool(false, "Th", group=days_group, inline="days2")
block_friday = input.bool(false, "Fr", group=days_group, inline="days2")
block_saturday = input.bool(false, "Sa", group=days_group, inline="days2")

// ===============================
// TP/SL SETTINGS
// ===============================
tpsl_group = "═══════════ TP/SL Settings ═══════════"
take_profit_percent = input.float(2.0, "Take Profit (%)", minval=0.1, maxval=20.0, step=0.1, group=tpsl_group)
stop_loss_percent = input.float(1.5, "Stop Loss (%)", minval=0.1, maxval=50.0, step=0.1, group=tpsl_group)
sl_equals_tp = input.bool(false, "SL=TP ? (for optimization)", group=tpsl_group)
close_only_profit = input.bool(false, "Close only in Profit", group=tpsl_group)
min_profit_percent = input.float(0.1, "Min Profit % for Close", minval=0.01, maxval=2.0, step=0.01, group=tpsl_group)

// Reverse Orders
use_reverse_order_on_sl = input.bool(false, "Reverse order on SL", group=tpsl_group)
use_reverse_order_on_be = input.bool(false, "Reverse order on BE", group=tpsl_group)
reverse_qty_percent = input.int(100, "Reverse Order Size (%)", minval=10, maxval=200, group=tpsl_group)

// ===============================
// BREAKEVEN SETTINGS
// ===============================
be_group = "═══════════ Breakeven ═══════════"
use_breakeven = input.bool(false, "Activate Breakeven", group=be_group)
breakeven_activation = input.float(1.0, "(%) to Activate Breakeven", minval=0.1, maxval=10.0, step=0.01, group=be_group)
breakeven_level = input.float(0.1, "New Breakeven SL (%)", minval=0.0, maxval=5.0, step=0.01, group=be_group)

// ===============================
// MULTI TAKE PROFITS
// ===============================
mtp_group = "═══════════ Multi Take Profits ═══════════"
use_multi_tp = input.bool(false, "Use Multiple Take Profits", group=mtp_group)
tp1_percent = input.float(0.6, "TP1 Profit (%)", minval=0.1, maxval=10.0, step=0.1, group=mtp_group)
tp1_qty = input.int(25, "TP1 Quantity (%)", minval=10, maxval=90, group=mtp_group)
tp2_percent = input.float(1.0, "TP2 Profit (%)", minval=0.1, maxval=15.0, step=0.1, group=mtp_group)
tp2_qty = input.int(25, "TP2 Quantity (%)", minval=10, maxval=90, group=mtp_group)
tp3_percent = input.float(1.5, "TP3 Profit (%)", minval=0.1, maxval=20.0, step=0.1, group=mtp_group)
tp3_qty = input.int(25, "TP3 Quantity (%)", minval=10, maxval=90, group=mtp_group)

// ===============================
// PYRAMIDING SETTINGS
// ===============================
pyr_group = "═══════════ Pyramiding ═══════════"
use_pyramiding = input.bool(false, "Use Pyramiding", group=pyr_group)
pyramid_min_move = input.float(0.5, "Min price move for pyramiding (%)", minval=0.1, maxval=5.0, step=0.1, group=pyr_group)

// ===============================
// TRAILING STOP
// ===============================
trail_group = "═══════════ Trailing Stop ═══════════"
use_trailing_stop = input.bool(false, "Use Trailing Stop", group=trail_group)
trailing_activation = input.float(1.5, "Activate Trailing Stop at %", minval=0.1, maxval=10.0, step=0.1, group=trail_group)
trailing_distance = input.float(0.5, "Distance from price to Trailing Stop (%)", minval=0.1, maxval=5.0, step=0.1, group=trail_group)

// ===============================
// ORDER INDENT
// ===============================
indent_group = "═══════════ Order Indent ═══════════"
use_order_indent = input.bool(false, "Use Order Indent", group=indent_group)
indent_percent = input.float(0.1, "Indent in %", minval=-2.0, maxval=2.0, step=0.01, group=indent_group)
indent_cancel_bars = input.int(15, "Cancel Indent Order After X Bars", minval=1, maxval=50, group=indent_group)

// ===============================
// ATR STOP LOSS AND TAKE PROFIT
// ===============================
atr_group = "═══════════ ATR SL/TP ═══════════"
use_atr_stop_loss = input.bool(false, "Use ATR Stop Loss", group=atr_group)
atr_sl_length = input.int(14, "ATR SL Length", minval=1, maxval=50, group=atr_group)
atr_sl_multiplier = input.float(2.0, "ATR SL Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

use_atr_take_profit = input.bool(false, "Use ATR Take Profit", group=atr_group)
atr_tp_length = input.int(14, "ATR TP Length", minval=1, maxval=50, group=atr_group)
atr_tp_multiplier = input.float(2.0, "ATR TP Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

// ===============================
// RSI SETTINGS
// ===============================
rsi_group = "═══════════ RSI ═══════════"
use_rsi = input.bool(false, "Use RSI", group=rsi_group)
rsi_length = input.int(14, "RSI Length", minval=2, maxval=100, group=rsi_group)
rsi_oversold = input.float(30, "RSI Oversold", minval=10, maxval=50, group=rsi_group)
rsi_overbought = input.float(70, "RSI Overbought", minval=50, maxval=90, group=rsi_group)
rsi_condition = input.string("Oversold", "RSI Condition", options=["Oversold", "Overbought", "Cross Level Up", "Cross Level Down", "Custom Range"], group=rsi_group)
rsi_custom_min = input.float(30, "RSI Custom Min", minval=0, maxval=100, group=rsi_group)
rsi_custom_max = input.float(70, "RSI Custom Max", minval=0, maxval=100, group=rsi_group)
rsi_tf = input.timeframe("", "RSI Timeframe", group=rsi_group)
rsi_use_signal_memory = input.bool(false, "RSI Use Signal Memory", group=rsi_group)
rsi_memory_bars = input.int(5, "RSI Memory Bars", minval=1, maxval=50, group=rsi_group)

// ===============================
// SUPERTREND SETTINGS
// ===============================
st_group = "═══════════ SuperTrend ═══════════"
use_supertrend = input.bool(false, "Use SuperTrend", group=st_group)
st_period = input.int(10, "SuperTrend Period", minval=1, maxval=50, group=st_group)
st_factor = input.float(3.0, "SuperTrend Factor", minval=0.5, maxval=10.0, step=0.1, group=st_group)
st_signal_type = input.string("Trend Filter", "SuperTrend Signal", options=["Trend Change", "Trend Filter"], group=st_group)
st_tf = input.timeframe("", "SuperTrend Timeframe", group=st_group)
st_use_signal_memory = input.bool(false, "SuperTrend Use Signal Memory", group=st_group)
st_memory_bars = input.int(5, "SuperTrend Memory Bars", minval=1, maxval=50, group=st_group)

// SuperTrend #2
use_supertrend2 = input.bool(false, "Use SuperTrend #2", group=st_group)
st2_period = input.int(21, "SuperTrend #2 Period", minval=1, maxval=50, group=st_group)
st2_factor = input.float(2.0, "SuperTrend #2 Factor", minval=0.5, maxval=10.0, step=0.1, group=st_group)
st2_signal_type = input.string("Trend Filter", "SuperTrend #2 Signal", options=["Trend Change", "Trend Filter"], group=st_group)
st2_tf = input.timeframe("", "SuperTrend #2 Timeframe", group=st_group)
st2_use_signal_memory = input.bool(false, "SuperTrend #2 Use Signal Memory", group=st_group)
st2_memory_bars = input.int(5, "SuperTrend #2 Memory Bars", minval=1, maxval=50, group=st_group)

// ===============================
// MOVING AVERAGES
// ===============================
ma_group = "═══════════ Two Moving Averages ═══════════"
use_ma = input.bool(false, "Use Moving Averages", group=ma_group)
ma_fast_length = input.int(10, "Fast MA Length", minval=2, maxval=200, group=ma_group)
ma_slow_length = input.int(30, "Slow MA Length", minval=2, maxval=200, group=ma_group)
ma_fast_type = input.string("EMA", "Fast MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_slow_type = input.string("EMA", "Slow MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_signal_type = input.string("Cross", "MA Signal Type", options=["Cross", "Direction", "Opposite Trend"], group=ma_group)
ma_tf = input.timeframe("", "MA Timeframe", group=ma_group)
ma_use_signal_memory = input.bool(false, "MA Use Signal Memory", group=ma_group)
ma_memory_bars = input.int(5, "MA Memory Bars", minval=1, maxval=50, group=ma_group)

// ===============================
// CHANNELS
// ===============================
channel_group = "═══════════ Channels ═══════════"
use_channels = input.bool(false, "Use Channels", group=channel_group)
channel_type = input.string("Bollinger Bands", "Channel Type", options=["Bollinger Bands", "Keltner Channel"], group=channel_group)
channel_length = input.int(20, "Channel Length", minval=5, maxval=100, group=channel_group)
channel_multiplier = input.float(2.0, "Channel Multiplier", minval=0.5, maxval=5.0, step=0.1, group=channel_group)
channel_signal_type = input.string("Rebound", "Channel Signal", options=["Rebound", "Breakout"], group=channel_group)
channel_tf = input.timeframe("", "Channel Timeframe", group=channel_group)
channel_use_signal_memory = input.bool(false, "Channel Use Signal Memory", group=channel_group)
channel_memory_bars = input.int(5, "Channel Memory Bars", minval=1, maxval=50, group=channel_group)

// ===============================
// STOCHASTIC
// ===============================
stoch_group = "═══════════ Stochastic ═══════════"
use_stochastic = input.bool(false, "Use Stochastic", group=stoch_group)
stoch_k_length = input.int(14, "Stochastic %K Length", minval=1, maxval=100, group=stoch_group)
stoch_k_smooth = input.int(1, "Stochastic %K Smoothing", minval=1, maxval=10, group=stoch_group)
stoch_d_smooth = input.int(3, "Stochastic %D Smoothing", minval=1, maxval=10, group=stoch_group)
stoch_overbought = input.float(80, "Stochastic Overbought", minval=50, maxval=100, group=stoch_group)
stoch_oversold = input.float(20, "Stochastic Oversold", minval=0, maxval=50, group=stoch_group)
stoch_signal_type = input.string("Oversold Cross", "Stochastic Signal", options=["Oversold Cross", "Overbought Cross", "K-D Cross"], group=stoch_group)
stoch_use_signal_memory = input.bool(false, "Stochastic Use Signal Memory", group=stoch_group)
stoch_memory_bars = input.int(5, "Stochastic Memory Bars", minval=1, maxval=50, group=stoch_group)

// ===============================
// ADDITIONAL INDICATORS
// ===============================
// MFI
mfi_group = "═══════════ MFI ═══════════"
use_mfi = input.bool(false, "Use MFI", group=mfi_group)
mfi_length = input.int(14, "MFI Length", minval=2, maxval=100, group=mfi_group)
mfi_overbought = input.float(80, "MFI Overbought", minval=50, maxval=90, group=mfi_group)
mfi_oversold = input.float(20, "MFI Oversold", minval=10, maxval=50, group=mfi_group)
mfi_use_signal_memory = input.bool(false, "MFI Use Signal Memory", group=mfi_group)
mfi_memory_bars = input.int(5, "MFI Memory Bars", minval=1, maxval=50, group=mfi_group)

// CCI
cci_group = "═══════════ CCI ═══════════"
use_cci = input.bool(false, "Use CCI", group=cci_group)
cci_length = input.int(20, "CCI Length", minval=5, maxval=200, group=cci_group)
cci_overbought = input.float(100, "CCI Overbought", minval=50, maxval=200, group=cci_group)
cci_oversold = input.float(-100, "CCI Oversold", minval=-200, maxval=-50, group=cci_group)
cci_use_signal_memory = input.bool(false, "CCI Use Signal Memory", group=cci_group)
cci_memory_bars = input.int(5, "CCI Memory Bars", minval=1, maxval=50, group=cci_group)

// MACD
macd_group = "═══════════ MACD ═══════════"
use_macd = input.bool(false, "Use MACD", group=macd_group)
macd_fast_length = input.int(12, "MACD Fast Length", minval=2, maxval=50, group=macd_group)
macd_slow_length = input.int(26, "MACD Slow Length", minval=5, maxval=100, group=macd_group)
macd_signal_length = input.int(9, "MACD Signal Length", minval=2, maxval=50, group=macd_group)
macd_condition = input.string("Signal Cross", "MACD Signal", options=["Signal Cross", "Zero Cross"], group=macd_group)
macd_use_signal_memory = input.bool(false, "MACD Use Signal Memory", group=macd_group)
macd_memory_bars = input.int(5, "MACD Memory Bars", minval=1, maxval=50, group=macd_group)

// ===============================
// SIGNAL INDICATORS
// ===============================
signals_group = "═══════════ Signal Indicators ═══════════"

// Highest/Lowest Bar
use_highlow = input.bool(false, "Use Highest/Lowest Bar", group=signals_group)
highlow_period = input.int(20, "High/Low Period", minval=5, maxval=200, group=signals_group)
highlow_use_signal_memory = input.bool(false, "High/Low Use Signal Memory", group=signals_group)
highlow_memory_bars = input.int(5, "High/Low Memory Bars", minval=1, maxval=50, group=signals_group)

// Accumulation Areas
use_accumulation = input.bool(false, "Use Accumulation Areas", group=signals_group)
accumulation_length = input.int(20, "Accumulation Length", minval=5, maxval=100, group=signals_group)
accumulation_range = input.float(1.0, "Max Range % for Accumulation", minval=0.1, maxval=5.0, step=0.1, group=signals_group)
accumulation_use_signal_memory = input.bool(false, "Accumulation Use Signal Memory", group=signals_group)
accumulation_memory_bars = input.int(5, "Accumulation Memory Bars", minval=1, maxval=50, group=signals_group)

// Pin Bar + MA
use_pinbar_ma = input.bool(false, "Use Pin Bar + MA", group=signals_group)
pinbar_ma_length = input.int(21, "Pin Bar MA Length", minval=5, maxval=200, group=signals_group)
pinbar_ma_use_signal_memory = input.bool(false, "Pin Bar MA Use Signal Memory", group=signals_group)
pinbar_ma_memory_bars = input.int(5, "Pin Bar MA Memory Bars", minval=1, maxval=50, group=signals_group)

// ===============================
// FILTERS
// ===============================
filters_group = "═══════════ Filters ═══════════"

// Volume Filter
use_volume_filter = input.bool(false, "Use Volume Filter", group=filters_group)
volume_length = input.int(20, "Volume Length", minval=5, maxval=100, group=filters_group)
volume_multiplier = input.float(1.5, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1, group=filters_group)

// Volatility Filter (ATR)
use_volatility_filter = input.bool(false, "Use Volatility Filter", group=filters_group)
volatility_length = input.int(20, "Volatility Length", minval=5, maxval=100, group=filters_group)
volatility_threshold = input.float(1.0, "Volatility Threshold", minval=0.1, maxval=10.0, step=0.1, group=filters_group)

// ===============================
// CLOSE CONDITIONS
// ===============================
close_group = "═══════════ Close Conditions ═══════════"
close_by_rsi = input.bool(false, "Close by RSI", group=close_group)
close_by_channel = input.bool(false, "Close by Channel", group=close_group)
close_by_ma_cross = input.bool(false, "Close by MA Cross", group=close_group)

// ===============================
// INDICATOR CALCULATIONS
// ===============================

// Time filters
date_filter = year >= start_year and year <= stop_year
day_blocked = (block_sunday and dayofweek == dayofweek.sunday) or 
              (block_monday and dayofweek == dayofweek.monday) or 
              (block_tuesday and dayofweek == dayofweek.tuesday) or 
              (block_wednesday and dayofweek == dayofweek.wednesday) or 
              (block_thursday and dayofweek == dayofweek.thursday) or 
              (block_friday and dayofweek == dayofweek.friday) or 
              (block_saturday and dayofweek == dayofweek.saturday)
time_trade_allowed = date_filter and not day_blocked

// SuperTrend calculations
var float st_line = na
var int st_direction = 1
[st_new_line, st_new_dir] = calculate_supertrend(high, low, close, st_factor, st_period, st_direction, st_line)
st_line := st_new_line
st_direction := st_new_dir

var float st2_line = na
var int st2_direction = 1
[st2_new_line, st2_new_dir] = calculate_supertrend(high, low, close, st2_factor, st2_period, st2_direction, st2_line)
st2_line := st2_new_line
st2_direction := st2_new_dir

// Moving Averages
ma_fast_calc = ma_function(close, ma_fast_length, ma_fast_type)
ma_slow_calc = ma_function(close, ma_slow_length, ma_slow_type)

// Bollinger Bands / Keltner Channel
channel_basis = channel_type == "Bollinger Bands" ? ta.sma(close, channel_length) : ta.ema(close, channel_length)
channel_dev = channel_type == "Bollinger Bands" ? channel_multiplier * ta.stdev(close, channel_length) : channel_multiplier * ta.atr(channel_length)
channel_upper = channel_basis + channel_dev
channel_lower = channel_basis - channel_dev

// RSI with MTF
rsi_calc = rsi_tf == "" ? ta.rsi(close, rsi_length) : request.security(syminfo.tickerid, rsi_tf, ta.rsi(close, rsi_length))

// Other indicators
stoch_k_raw = ta.stoch(close, high, low, stoch_k_length)
stoch_k_calc = ta.sma(stoch_k_raw, stoch_k_smooth)
stoch_d_calc = ta.sma(stoch_k_calc, stoch_d_smooth)

mfi_calc = ta.mfi(hlc3, mfi_length)
cci_calc = ta.cci(hlc3, cci_length)
[macd_line, macd_signal, macd_hist] = ta.macd(close, macd_fast_length, macd_slow_length, macd_signal_length)

// Volume and Volatility
volume_avg = ta.sma(volume, volume_length)
volatility_calc = ta.stdev(close, volatility_length) / ta.sma(close, volatility_length) * 100

// Pin Bar detection
is_pin_bar() =>
    body = math.abs(close - open)
    upper_shadow = high - math.max(open, close)
    lower_shadow = math.min(open, close) - low
    total_range = high - low
    
    // Long pin bar (hammer)
    long_pin = lower_shadow > body * 2 and upper_shadow < body * 0.5 and total_range > ta.atr(14) * 0.5
    // Short pin bar (shooting star)
    short_pin = upper_shadow > body * 2 and lower_shadow < body * 0.5 and total_range > ta.atr(14) * 0.5
    
    [long_pin, short_pin]

[pin_long, pin_short] = is_pin_bar()

// ===============================
// SIGNAL ARCHITECTURE WITH MEMORY
// ===============================

// Initialize counters
active_conditions_long = 0
met_conditions_long = 0
active_conditions_short = 0
met_conditions_short = 0

// RSI Signals with Memory
if use_rsi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    rsi_long_pure = false
    rsi_short_pure = false
    
    if rsi_condition == "Oversold"
        rsi_long_pure := rsi_calc <= rsi_oversold
        rsi_short_pure := rsi_calc >= rsi_overbought
    else if rsi_condition == "Overbought"
        rsi_long_pure := rsi_calc >= rsi_overbought
        rsi_short_pure := rsi_calc <= rsi_oversold
    else if rsi_condition == "Cross Level Up"
        rsi_long_pure := ta.crossover(rsi_calc, rsi_oversold)
        rsi_short_pure := ta.crossunder(rsi_calc, rsi_overbought)
    else if rsi_condition == "Cross Level Down"
        rsi_long_pure := ta.crossunder(rsi_calc, rsi_overbought)
        rsi_short_pure := ta.crossover(rsi_calc, rsi_oversold)
    else if rsi_condition == "Custom Range"
        rsi_long_pure := rsi_calc >= rsi_custom_min and rsi_calc <= rsi_custom_max
        rsi_short_pure := rsi_calc <= rsi_custom_min or rsi_calc >= rsi_custom_max
    
    // Update signal memory
    if rsi_long_pure
        rsi_long_signal_bar := bar_index
    if rsi_short_pure
        rsi_short_signal_bar := bar_index
    
    // Final signals (pure OR memory)
    rsi_long_final = rsi_long_pure or (rsi_use_signal_memory and bar_index - rsi_long_signal_bar <= rsi_memory_bars)
    rsi_short_final = rsi_short_pure or (rsi_use_signal_memory and bar_index - rsi_short_signal_bar <= rsi_memory_bars)
    
    if rsi_long_final
        met_conditions_long += 1
    if rsi_short_final
        met_conditions_short += 1

// SuperTrend Signals with Memory
if use_supertrend
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    st_long_pure = false
    st_short_pure = false
    
    if st_signal_type == "Trend Change"
        st_long_pure := st_direction == 1 and st_direction[1] == -1
        st_short_pure := st_direction == -1 and st_direction[1] == 1
    else if st_signal_type == "Trend Filter"
        st_long_pure := st_direction == 1
        st_short_pure := st_direction == -1
    
    // Update signal memory
    if st_long_pure
        st_long_signal_bar := bar_index
    if st_short_pure
        st_short_signal_bar := bar_index
    
    // Final signals
    st_long_final = st_long_pure or (st_use_signal_memory and bar_index - st_long_signal_bar <= st_memory_bars)
    st_short_final = st_short_pure or (st_use_signal_memory and bar_index - st_short_signal_bar <= st_memory_bars)
    
    if st_long_final
        met_conditions_long += 1
    if st_short_final
        met_conditions_short += 1

// SuperTrend #2 Signals with Memory
if use_supertrend2
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    st2_long_pure = false
    st2_short_pure = false
    
    if st2_signal_type == "Trend Change"
        st2_long_pure := st2_direction == 1 and st2_direction[1] == -1
        st2_short_pure := st2_direction == -1 and st2_direction[1] == 1
    else if st2_signal_type == "Trend Filter"
        st2_long_pure := st2_direction == 1
        st2_short_pure := st2_direction == -1
    
    // Update signal memory
    if st2_long_pure
        st2_long_signal_bar := bar_index
    if st2_short_pure
        st2_short_signal_bar := bar_index
    
    // Final signals
    st2_long_final = st2_long_pure or (st2_use_signal_memory and bar_index - st2_long_signal_bar <= st2_memory_bars)
    st2_short_final = st2_short_pure or (st2_use_signal_memory and bar_index - st2_short_signal_bar <= st2_memory_bars)
    
    if st2_long_final
        met_conditions_long += 1
    if st2_short_final
        met_conditions_short += 1

// Moving Averages Signals with Memory
if use_ma
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    ma_long_pure = false
    ma_short_pure = false
    
    if ma_signal_type == "Cross"
        ma_long_pure := ta.crossover(ma_fast_calc, ma_slow_calc)
        ma_short_pure := ta.crossunder(ma_fast_calc, ma_slow_calc)
    else if ma_signal_type == "Direction"
        ma_long_pure := ma_fast_calc > ma_fast_calc[1] and ma_slow_calc > ma_slow_calc[1]
        ma_short_pure := ma_fast_calc < ma_fast_calc[1] and ma_slow_calc < ma_slow_calc[1]
    else if ma_signal_type == "Opposite Trend"
        ma_long_pure := ma_fast_calc < ma_slow_calc and close < ma_slow_calc
        ma_short_pure := ma_fast_calc > ma_slow_calc and close > ma_slow_calc
    
    // Update signal memory
    if ma_long_pure
        ma_long_signal_bar := bar_index
    if ma_short_pure
        ma_short_signal_bar := bar_index
    
    // Final signals
    ma_long_final = ma_long_pure or (ma_use_signal_memory and bar_index - ma_long_signal_bar <= ma_memory_bars)
    ma_short_final = ma_short_pure or (ma_use_signal_memory and bar_index - ma_short_signal_bar <= ma_memory_bars)
    
    if ma_long_final
        met_conditions_long += 1
    if ma_short_final
        met_conditions_short += 1

// Channels Signals with Memory
if use_channels
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    channel_long_pure = false
    channel_short_pure = false
    
    if channel_signal_type == "Rebound"
        channel_long_pure := low <= channel_lower and close > channel_lower
        channel_short_pure := high >= channel_upper and close < channel_upper
    else if channel_signal_type == "Breakout"
        channel_long_pure := close > channel_upper
        channel_short_pure := close < channel_lower
    
    // Update signal memory
    if channel_long_pure
        channel_long_signal_bar := bar_index
    if channel_short_pure
        channel_short_signal_bar := bar_index
    
    // Final signals
    channel_long_final = channel_long_pure or (channel_use_signal_memory and bar_index - channel_long_signal_bar <= channel_memory_bars)
    channel_short_final = channel_short_pure or (channel_use_signal_memory and bar_index - channel_short_signal_bar <= channel_memory_bars)
    
    if channel_long_final
        met_conditions_long += 1
    if channel_short_final
        met_conditions_short += 1

// Stochastic Signals with Memory
if use_stochastic
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    stoch_long_pure = false
    stoch_short_pure = false
    
    if stoch_signal_type == "Oversold Cross"
        stoch_long_pure := ta.crossover(stoch_k_calc, stoch_oversold)
        stoch_short_pure := ta.crossunder(stoch_k_calc, stoch_overbought)
    else if stoch_signal_type == "Overbought Cross"
        stoch_long_pure := ta.crossunder(stoch_k_calc, stoch_overbought)
        stoch_short_pure := ta.crossover(stoch_k_calc, stoch_oversold)
    else if stoch_signal_type == "K-D Cross"
        stoch_long_pure := ta.crossover(stoch_k_calc, stoch_d_calc)
        stoch_short_pure := ta.crossunder(stoch_k_calc, stoch_d_calc)
    
    // Update signal memory
    if stoch_long_pure
        stoch_long_signal_bar := bar_index
    if stoch_short_pure
        stoch_short_signal_bar := bar_index
    
    // Final signals
    stoch_long_final = stoch_long_pure or (stoch_use_signal_memory and bar_index - stoch_long_signal_bar <= stoch_memory_bars)
    stoch_short_final = stoch_short_pure or (stoch_use_signal_memory and bar_index - stoch_short_signal_bar <= stoch_memory_bars)
    
    if stoch_long_final
        met_conditions_long += 1
    if stoch_short_final
        met_conditions_short += 1

// MFI Signals with Memory
if use_mfi
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    mfi_long_pure = mfi_calc <= mfi_oversold
    mfi_short_pure = mfi_calc >= mfi_overbought
    
    // Update signal memory
    if mfi_long_pure
        mfi_long_signal_bar := bar_index
    if mfi_short_pure
        mfi_short_signal_bar := bar_index
    
    // Final signals
    mfi_long_final = mfi_long_pure or (mfi_use_signal_memory and bar_index - mfi_long_signal_bar <= mfi_memory_bars)
    mfi_short_final = mfi_short_pure or (mfi_use_signal_memory and bar_index - mfi_short_signal_bar <= mfi_memory_bars)
    
    if mfi_long_final
        met_conditions_long += 1
    if mfi_short_final
        met_conditions_short += 1

// CCI Signals with Memory
if use_cci
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    cci_long_pure = cci_calc <= cci_oversold
    cci_short_pure = cci_calc >= cci_overbought
    
    // Update signal memory
    if cci_long_pure
        cci_long_signal_bar := bar_index
    if cci_short_pure
        cci_short_signal_bar := bar_index
    
    // Final signals
    cci_long_final = cci_long_pure or (cci_use_signal_memory and bar_index - cci_long_signal_bar <= cci_memory_bars)
    cci_short_final = cci_short_pure or (cci_use_signal_memory and bar_index - cci_short_signal_bar <= cci_memory_bars)
    
    if cci_long_final
        met_conditions_long += 1
    if cci_short_final
        met_conditions_short += 1

// MACD Signals with Memory
if use_macd
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    macd_long_pure = false
    macd_short_pure = false
    
    if macd_condition == "Signal Cross"
        macd_long_pure := ta.crossover(macd_line, macd_signal)
        macd_short_pure := ta.crossunder(macd_line, macd_signal)
    else if macd_condition == "Zero Cross"
        macd_long_pure := ta.crossover(macd_line, 0)
        macd_short_pure := ta.crossunder(macd_line, 0)
    
    // Update signal memory
    if macd_long_pure
        macd_long_signal_bar := bar_index
    if macd_short_pure
        macd_short_signal_bar := bar_index
    
    // Final signals
    macd_long_final = macd_long_pure or (macd_use_signal_memory and bar_index - macd_long_signal_bar <= macd_memory_bars)
    macd_short_final = macd_short_pure or (macd_use_signal_memory and bar_index - macd_short_signal_bar <= macd_memory_bars)
    
    if macd_long_final
        met_conditions_long += 1
    if macd_short_final
        met_conditions_short += 1

// Highest/Lowest Bar Signals with Memory
if use_highlow
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    highlow_long_pure = high == ta.highest(high, highlow_period)
    highlow_short_pure = low == ta.lowest(low, highlow_period)
    
    // Update signal memory
    if highlow_long_pure
        highlow_long_signal_bar := bar_index
    if highlow_short_pure
        highlow_short_signal_bar := bar_index
    
    // Final signals
    highlow_long_final = highlow_long_pure or (highlow_use_signal_memory and bar_index - highlow_long_signal_bar <= highlow_memory_bars)
    highlow_short_final = highlow_short_pure or (highlow_use_signal_memory and bar_index - highlow_short_signal_bar <= highlow_memory_bars)
    
    if highlow_long_final
        met_conditions_long += 1
    if highlow_short_final
        met_conditions_short += 1

// Accumulation Areas Signals with Memory
if use_accumulation
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    highest_acc = ta.highest(high, accumulation_length)
    lowest_acc = ta.lowest(low, accumulation_length)
    range_acc = (highest_acc - lowest_acc) / lowest_acc * 100
    in_accumulation = range_acc <= accumulation_range
    
    accumulation_long_pure = in_accumulation and close > ta.sma(close, accumulation_length)
    accumulation_short_pure = in_accumulation and close < ta.sma(close, accumulation_length)
    
    // Update signal memory
    if accumulation_long_pure
        accumulation_long_signal_bar := bar_index
    if accumulation_short_pure
        accumulation_short_signal_bar := bar_index
    
    // Final signals
    accumulation_long_final = accumulation_long_pure or (accumulation_use_signal_memory and bar_index - accumulation_long_signal_bar <= accumulation_memory_bars)
    accumulation_short_final = accumulation_short_pure or (accumulation_use_signal_memory and bar_index - accumulation_short_signal_bar <= accumulation_memory_bars)
    
    if accumulation_long_final
        met_conditions_long += 1
    if accumulation_short_final
        met_conditions_short += 1

// Pin Bar + MA Signals with Memory
if use_pinbar_ma
    active_conditions_long += 1
    active_conditions_short += 1
    
    // Calculate pure signals
    ma_pinbar = ta.sma(close, pinbar_ma_length)
    pinbar_long_pure = pin_long and close > ma_pinbar and low < ma_pinbar
    pinbar_short_pure = pin_short and close < ma_pinbar and high > ma_pinbar
    
    // Update signal memory
    if pinbar_long_pure
        pinbar_ma_long_signal_bar := bar_index
    if pinbar_short_pure
        pinbar_ma_short_signal_bar := bar_index
    
    // Final signals
    pinbar_long_final = pinbar_long_pure or (pinbar_ma_use_signal_memory and bar_index - pinbar_ma_long_signal_bar <= pinbar_ma_memory_bars)
    pinbar_short_final = pinbar_short_pure or (pinbar_ma_use_signal_memory and bar_index - pinbar_ma_short_signal_bar <= pinbar_ma_memory_bars)
    
    if pinbar_long_final
        met_conditions_long += 1
    if pinbar_short_final
        met_conditions_short += 1

// ===============================
// FILTERS
// ===============================

// Volume Filter
volume_filter_passed = true
if use_volume_filter
    volume_filter_passed := volume > volume_avg * volume_multiplier

// Volatility Filter
volatility_filter_passed = true
if use_volatility_filter
    volatility_filter_passed := volatility_calc > volatility_threshold

// Combine all filters
all_filters_passed = volume_filter_passed and volatility_filter_passed

// ===============================
// ENTRY CONDITIONS
// ===============================

// Entry cooldown
can_enter = bar_index - last_entry_bar_index >= entry_cooldown_bars

// Final entry conditions
entry_conditions_met_long = (active_conditions_long > 0 and met_conditions_long == active_conditions_long) or (active_conditions_long == 0 and allow_entry_without_indicators)
entry_conditions_met_short = (active_conditions_short > 0 and met_conditions_short == active_conditions_short) or (active_conditions_short == 0 and allow_entry_without_indicators)

final_long_signal = use_long_trades and time_trade_allowed and entry_conditions_met_long and all_filters_passed and strategy.position_size == 0 and can_enter and barstate.isconfirmed
final_short_signal = use_short_trades and time_trade_allowed and entry_conditions_met_short and all_filters_passed and strategy.position_size == 0 and can_enter and barstate.isconfirmed

// Order Indent Variables
var float indent_target_price = na
var int indent_bar_counter = 0

// ===============================
// STRATEGY EXECUTION
// ===============================

// Order Indent Logic
if use_order_indent and (final_long_signal or final_short_signal) and strategy.position_size == 0
    indent_direction = final_long_signal ? -1 : 1
    indent_target_price := close * (1 + indent_direction * indent_percent / 100)
    indent_bar_counter := 0

if not na(indent_target_price)
    indent_bar_counter += 1
    if indent_bar_counter > indent_cancel_bars
        indent_target_price := na
        indent_bar_counter := 0

// Execute Orders
if final_long_signal and strategy.position_size == 0
    if use_order_indent
        indent_target_price := close * (1 - indent_percent / 100)
        indent_bar_counter := 0
    else
        strategy.entry("Long", strategy.long)
        last_entry_bar_index := bar_index

if final_short_signal and strategy.position_size == 0
    if use_order_indent
        indent_target_price := close * (1 + indent_percent / 100)
        indent_bar_counter := 0
    else
        strategy.entry("Short", strategy.short)
        last_entry_bar_index := bar_index

// Execute indent orders
if not na(indent_target_price) and strategy.position_size == 0
    if final_long_signal and close <= indent_target_price
        strategy.entry("Long", strategy.long)
        last_entry_bar_index := bar_index
        indent_target_price := na
        indent_bar_counter := 0
    
    if final_short_signal and close >= indent_target_price
        strategy.entry("Short", strategy.short)
        last_entry_bar_index := bar_index
        indent_target_price := na
        indent_bar_counter := 0

// ===============================
// EXIT MANAGEMENT
// ===============================

// Calculate TP/SL levels
sl_percent_final = sl_equals_tp ? take_profit_percent : stop_loss_percent
avg_price = strategy.position_avg_price

// ATR values
atr_sl_val = ta.atr(atr_sl_length)
atr_tp_val = ta.atr(atr_tp_length)

// Breakeven Logic
if use_breakeven and strategy.position_size != 0 and not breakeven_activated
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= breakeven_activation
        breakeven_activated := true

// Trailing Stop Logic
if use_trailing_stop and strategy.position_size != 0
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= trailing_activation
        if strategy.position_size > 0
            new_trailing_level = close * (1 - trailing_distance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.max(trailing_stop_level, new_trailing_level)
        else
            new_trailing_level = close * (1 + trailing_distance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.min(trailing_stop_level, new_trailing_level)

// TP/SL Execution
if strategy.position_size != 0
    tp_level = 0.0
    sl_level = 0.0
    
    if strategy.position_size > 0
        // Long position
        tp_level := use_atr_take_profit ? avg_price + atr_tp_val * atr_tp_multiplier : avg_price * (1 + take_profit_percent / 100)
        sl_level := use_atr_stop_loss ? avg_price - atr_sl_val * atr_sl_multiplier : avg_price * (1 - sl_percent_final / 100)
        
        // Apply breakeven
        if use_breakeven and breakeven_activated
            breakeven_sl_level = avg_price * (1 + breakeven_level / 100)
            sl_level := math.max(sl_level, breakeven_sl_level)
        
        // Apply trailing stop
        if use_trailing_stop and not na(trailing_stop_level)
            sl_level := math.max(sl_level, trailing_stop_level)
        
        // Multi TP or regular exit
        if use_multi_tp
            total_qty = math.abs(strategy.position_size)
            tp1_price = avg_price * (1 + tp1_percent / 100)
            tp2_price = avg_price * (1 + tp2_percent / 100)
            tp3_price = avg_price * (1 + tp3_percent / 100)
            
            tp1_qty_calc = total_qty * tp1_qty / 100
            tp2_qty_calc = total_qty * tp2_qty / 100
            tp3_qty_calc = total_qty * tp3_qty / 100
            remaining_qty = total_qty - tp1_qty_calc - tp2_qty_calc - tp3_qty_calc
            
            strategy.order("TP1", strategy.short, qty=tp1_qty_calc, limit=tp1_price)
            strategy.order("TP2", strategy.short, qty=tp2_qty_calc, limit=tp2_price)
            strategy.order("TP3", strategy.short, qty=tp3_qty_calc, limit=tp3_price)
            strategy.order("TP4", strategy.short, qty=remaining_qty, limit=tp_level)
            strategy.order("SL", strategy.short, qty=total_qty, stop=sl_level)
        else
            strategy.exit("Exit", limit=tp_level, stop=sl_level)
    
    else
        // Short position
        tp_level := use_atr_take_profit ? avg_price - atr_tp_val * atr_tp_multiplier : avg_price * (1 - take_profit_percent / 100)
        sl_level := use_atr_stop_loss ? avg_price + atr_sl_val * atr_sl_multiplier : avg_price * (1 + sl_percent_final / 100)
        
        // Apply breakeven
        if use_breakeven and breakeven_activated
            breakeven_sl_level = avg_price * (1 - breakeven_level / 100)
            sl_level := math.min(sl_level, breakeven_sl_level)
        
        // Apply trailing stop
        if use_trailing_stop and not na(trailing_stop_level)
            sl_level := math.min(sl_level, trailing_stop_level)
        
        // Multi TP or regular exit
        if use_multi_tp
            total_qty = math.abs(strategy.position_size)
            tp1_price = avg_price * (1 - tp1_percent / 100)
            tp2_price = avg_price * (1 - tp2_percent / 100)
            tp3_price = avg_price * (1 - tp3_percent / 100)
            
            tp1_qty_calc = total_qty * tp1_qty / 100
            tp2_qty_calc = total_qty * tp2_qty / 100
            tp3_qty_calc = total_qty * tp3_qty / 100
            remaining_qty = total_qty - tp1_qty_calc - tp2_qty_calc - tp3_qty_calc
            
            strategy.order("TP1", strategy.long, qty=tp1_qty_calc, limit=tp1_price)
            strategy.order("TP2", strategy.long, qty=tp2_qty_calc, limit=tp2_price)
            strategy.order("TP3", strategy.long, qty=tp3_qty_calc, limit=tp3_price)
            strategy.order("TP4", strategy.long, qty=remaining_qty, limit=tp_level)
            strategy.order("SL", strategy.long, qty=total_qty, stop=sl_level)
        else
            strategy.exit("Exit", limit=tp_level, stop=sl_level)

// ===============================
// CLOSE CONDITIONS
// ===============================

// Check profit condition for close signals
profit_check_passed = true
if close_only_profit
    profit_check_passed := strategy.openprofit >= avg_price * min_profit_percent / 100

// RSI Close
if close_by_rsi and strategy.position_size != 0 and use_rsi and profit_check_passed
    rsi_close_condition = (strategy.position_size > 0 and rsi_calc > rsi_overbought) or (strategy.position_size < 0 and rsi_calc < rsi_oversold)
    if rsi_close_condition
        strategy.close_all(comment="RSI Close")

// Channel Close
if close_by_channel and strategy.position_size != 0 and use_channels and profit_check_passed
    channel_close_condition = (strategy.position_size > 0 and close > channel_upper) or (strategy.position_size < 0 and close < channel_lower)
    if channel_close_condition
        strategy.close_all(comment="Channel Close")

// MA Cross Close
if close_by_ma_cross and strategy.position_size != 0 and use_ma and profit_check_passed
    ma_close_condition = (strategy.position_size > 0 and ta.crossunder(ma_fast_calc, ma_slow_calc)) or (strategy.position_size < 0 and ta.crossover(ma_fast_calc, ma_slow_calc))
    if ma_close_condition
        strategy.close_all(comment="MA Close")

// Pyramiding Logic
if use_pyramiding and strategy.position_size != 0
    price_move = 0.0
    if strategy.position_size > 0
        price_move := (close - avg_price) / avg_price * 100
    else
        price_move := (avg_price - close) / avg_price * 100
    
    if price_move >= pyramid_min_move
        if strategy.position_size > 0 and final_long_signal
            strategy.entry("Pyramid L", strategy.long)
        if strategy.position_size < 0 and final_short_signal
            strategy.entry("Pyramid S", strategy.short)

// Reverse Orders Logic
if use_reverse_order_on_sl and strategy.closedtrades > 0
    last_trade = strategy.closedtrades - 1
    last_profit = strategy.closedtrades.profit(last_trade)
    
    if last_profit < 0 and barstate.isconfirmed and strategy.position_size == 0
        last_size = strategy.closedtrades.size(last_trade)
        reverse_qty = math.abs(last_size) * reverse_qty_percent / 100
        
        if last_size > 0
            strategy.entry("Rev S", strategy.short, qty=reverse_qty)
        else
            strategy.entry("Rev L", strategy.long, qty=reverse_qty)
        
        // Reset state variables
        trailing_stop_level := na
        breakeven_activated := false

if use_reverse_order_on_be and strategy.closedtrades > 0 and breakeven_activated
    last_trade = strategy.closedtrades - 1
    last_profit = strategy.closedtrades.profit(last_trade)
    
    if last_profit >= 0 and last_profit <= avg_price * breakeven_level / 100 and barstate.isconfirmed and strategy.position_size == 0
        last_size = strategy.closedtrades.size(last_trade)
        reverse_qty = math.abs(last_size) * reverse_qty_percent / 100
        
        if last_size > 0
            strategy.entry("Rev BE S", strategy.short, qty=reverse_qty)
        else
            strategy.entry("Rev BE L", strategy.long, qty=reverse_qty)
        
        // Reset state variables
        trailing_stop_level := na
        breakeven_activated := false

// Reset variables when position closes
if strategy.position_size == 0 and strategy.position_size[1] != 0
    trailing_stop_level := na
    breakeven_activated := false

// ===============================
// VISUALIZATION
// ===============================

// Plot indicators
plot(use_ma ? ma_fast_calc : na, "Fast MA", color=color.blue, linewidth=1)
plot(use_ma ? ma_slow_calc : na, "Slow MA", color=color.red, linewidth=1)
plot(use_supertrend ? st_line : na, "SuperTrend", color=st_direction == 1 ? color.green : color.red, linewidth=2)
plot(use_supertrend2 ? st2_line : na, "SuperTrend #2", color=st2_direction == 1 ? color.lime : color.maroon, linewidth=1)

// Plot channels
plot(use_channels ? channel_upper : na, "Channel Upper", color=color.purple)
plot(use_channels ? channel_basis : na, "Channel Basis", color=color.gray)
plot(use_channels ? channel_lower : na, "Channel Lower", color=color.purple)

// Signal visualization
if show_entry_signals and (show_all_signals or strategy.position_size == 0)
    if final_long_signal
        label.new(bar_index, low - ta.atr(14), "LONG\n" + str.tostring(met_conditions_long) + "/" + str.tostring(active_conditions_long), 
                  color=color.green, style=label.style_label_up, textcolor=color.white, size=size.normal)
    
    if final_short_signal
        label.new(bar_index, high + ta.atr(14), "SHORT\n" + str.tostring(met_conditions_short) + "/" + str.tostring(active_conditions_short), 
                  color=color.red, style=label.style_label_down, textcolor=color.white, size=size.normal)

// ===============================
// INFORMATION TABLE
// ===============================

if barstate.islast
    var table info_table = table.new(position.top_right, 3, 8, bgcolor=color.new(color.black, 90), border_width=1)
    
    table.cell(info_table, 0, 0, "Multi Scalping Status", bgcolor=color.blue, text_color=color.white)
    table.cell(info_table, 1, 0, "Long", bgcolor=color.blue, text_color=color.white)
    table.cell(info_table, 2, 0, "Short", bgcolor=color.blue, text_color=color.white)
    
    table.cell(info_table, 0, 1, "Active Conditions:", text_color=color.white)
    table.cell(info_table, 1, 1, str.tostring(active_conditions_long), text_color=color.white)
    table.cell(info_table, 2, 1, str.tostring(active_conditions_short), text_color=color.white)
    
    table.cell(info_table, 0, 2, "Met Conditions:", text_color=color.white)
    table.cell(info_table, 1, 2, str.tostring(met_conditions_long), text_color=color.white)
    table.cell(info_table, 2, 2, str.tostring(met_conditions_short), text_color=color.white)
    
    table.cell(info_table, 0, 3, "Filters:", text_color=color.white)
    table.cell(info_table, 1, 3, all_filters_passed ? "✓" : "✗", text_color=all_filters_passed ? color.green : color.red)
    table.cell(info_table, 2, 3, all_filters_passed ? "✓" : "✗", text_color=all_filters_passed ? color.green : color.red)
    
    table.cell(info_table, 0, 4, "Final Signal:", text_color=color.white)
    table.cell(info_table, 1, 4, final_long_signal ? "BUY" : "-", text_color=final_long_signal ? color.green : color.gray)
    table.cell(info_table, 2, 4, final_short_signal ? "SELL" : "-", text_color=final_short_signal ? color.red : color.gray)
    
    table.cell(info_table, 0, 5, "Position:", text_color=color.white)
    table.cell(info_table, 1, 5, str.tostring(strategy.position_size), text_color=strategy.position_size == 0 ? color.green : color.yellow)
    table.cell(info_table, 2, 5, str.tostring(strategy.openprofit) + "$", text_color=strategy.openprofit >= 0 ? color.green : color.red)
    
    table.cell(info_table, 0, 6, "Breakeven:", text_color=color.white)
    table.cell(info_table, 1, 6, breakeven_activated ? "Active" : "Inactive", text_color=breakeven_activated ? color.green : color.gray)
    table.cell(info_table, 2, 6, "", text_color=color.white)

// ===============================
// ALERTS
// ===============================
if final_long_signal
    alert_msg = '{"action": "LONG", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + ', "conditions": ' + str.tostring(met_conditions_long) + '/' + str.tostring(active_conditions_long) + '}'
    alert(alert_msg, alert.freq_once_per_bar)

if final_short_signal
    alert_msg = '{"action": "SHORT", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + ', "conditions": ' + str.tostring(met_conditions_short) + '/' + str.tostring(active_conditions_short) + '}'
    alert(alert_msg, alert.freq_once_per_bar)

if strategy.position_size[1] != 0 and strategy.position_size == 0
    alert_msg = '{"action": "CLOSE", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + '}'
    alert(alert_msg, alert.freq_once_per_bar)
