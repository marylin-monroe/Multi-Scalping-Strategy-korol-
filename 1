// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © polypokrbinc
//@version=5

strategy("Multi Scalping Strategy [Dimkud]", shorttitle="MSS", overlay=true, pyramiding=3, default_qty_type=strategy.percent_of_equity, default_qty_value=10, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.1, calc_on_order_fills=true, calc_on_every_tick=false, max_labels_count=500, max_lines_count=500, max_bars_back=5000, process_orders_on_close=true, fill_orders_on_standard_ohlc=true)

// ===============================
// SIGNAL MEMORY VARIABLES
// ===============================
var int macd_long_signal_bar = 0
var int macd_short_signal_bar = 0
var int rsi_long_signal_bar = 0
var int rsi_short_signal_bar = 0
var int stoch_long_signal_bar = 0
var int stoch_short_signal_bar = 0
var int stoch_kd_long_signal_bar = 0
var int stoch_kd_short_signal_bar = 0
var int ma_long_signal_bar = 0
var int ma_short_signal_bar = 0
var int qqe_long_signal_bar = 0
var int qqe_short_signal_bar = 0
var int div_long_signal_bar = 0
var int div_short_signal_bar = 0
var int lrc_long_signal_bar = 0
var int lrc_short_signal_bar = 0
var int cmf_long_signal_bar = 0
var int cmf_short_signal_bar = 0
var int bop_long_signal_bar = 0
var int bop_short_signal_bar = 0
var int candle_long_signal_bar = 0
var int candle_short_signal_bar = 0

// Position management variables
var float trailing_stop_level = na
var bool breakeven_activated = false
var int last_entry_bar_index = 0
var bool tp1_executed = false
var bool tp2_executed = false
var bool tp3_executed = false
var bool tp4_executed = false
var float entry_price = na
var float indent_long_price = na
var float indent_short_price = na
var int indent_order_bar = 0

// ===============================
// BASIC TRADING SETTINGS
// ===============================
basic_group = "=============== BASIC TRADING SETTINGS =============="
use_long_trades = input.bool(false, "Use Long ?", group=basic_group)
use_short_trades = input.bool(true, "Use Short ?", group=basic_group)
allow_entry_without_indicators = input.bool(false, "Allow Entry if NO Indicators Active?", group=basic_group)
min_bars_between_entries = input.int(5, "Min Bars Between Entries", minval=0, maxval=100, group=basic_group)

// ===============================
// VISUALIZATION
// ===============================
viz_group = "=============== VISUALIZATION ==============="
show_tp_sl = input.bool(false, "Display Visualisation for TP/SL ?", group=viz_group)
show_entry_signals = input.bool(false, "Show Signals ?", group=viz_group)
show_all_signals = input.bool(false, "Show All Signals (even if position open)", group=viz_group)

// ===============================
// TIME FILTER (USE FOR TESTS)
// ===============================
time_group = "========== TIME FILTER (USE FOR TESTS) ==========="
block_sunday = input.bool(false, "Su", group=time_group, inline="days1")
block_monday = input.bool(false, "Mo", group=time_group, inline="days1") 
block_tuesday = input.bool(false, "Tu", group=time_group, inline="days1")
block_wednesday = input.bool(false, "We", group=time_group, inline="days1")
block_thursday = input.bool(false, "Th", group=time_group, inline="days2")
block_friday = input.bool(false, "Fr", group=time_group, inline="days2")
block_saturday = input.bool(false, "Sa - Days To Block", group=time_group, inline="days2")

start_year = input.int(2022, "Start Year", group=time_group, inline="year1")
start_month = input.int(5, "", group=time_group, inline="year1", minval=1, maxval=12)
start_day = input.int(1, "", group=time_group, inline="year1", minval=1, maxval=31)

stop_year = input.int(2030, "Stop Year", group=time_group, inline="year2")
stop_month = input.int(12, "", group=time_group, inline="year2", minval=1, maxval=12)
stop_day = input.int(30, "", group=time_group, inline="year2", minval=1, maxval=31)

// ===============================
// STATIC SL/TP
// ===============================
static_group = "======== STATIC SL/TP ========"
sl_equals_tp = input.bool(false, "SL = TP ?", group=static_group)
take_profit_percent = input.float(1.5, "Take Profit (%)", minval=0.1, maxval=20.0, step=0.1, group=static_group)
stop_loss_percent = input.float(1.5, "Stop Loss (%)", minval=0.1, maxval=50.0, step=0.1, group=static_group)

close_only_profit = input.bool(false, "Close only in Profit. (Used only for \"Close Conditions\")", group=static_group)
activate_breakeven = input.bool(false, "Activate Breakeven ?", group=static_group)
breakeven_activation = input.float(0.5, "(%) to Activate Breakeven", minval=0.1, maxval=10.0, step=0.01, group=static_group)
breakeven_level = input.float(0.1, "New Breakeven SL (%)", minval=0.0, maxval=5.0, step=0.01, group=static_group)

// ===============================
// Multiple Take Profits
// ===============================
mtp_group = "====== Use Multiple Take Profits ? ======"
use_multiple_tp = input.bool(false, "====== Use Multiple Take Profits ? ======", group=mtp_group)
tp1_percent = input.float(0.2, "Profit Percent for 1 TP (%)", minval=0.1, maxval=10.0, step=0.1, group=mtp_group)
tp1_qty = input.int(10, "Value of 1 TP (%)", minval=10, maxval=90, group=mtp_group)
tp2_percent = input.float(0.5, "Profit Percent for 2 TP (%)", minval=0.1, maxval=15.0, step=0.1, group=mtp_group)
tp2_qty = input.int(20, "Value of 2 TP (%)", minval=10, maxval=90, group=mtp_group)
tp3_percent = input.float(1.0, "Profit Percent for 3 TP (%)", minval=0.1, maxval=20.0, step=0.1, group=mtp_group)
tp3_qty = input.int(40, "Value of 3 TP (%)", minval=10, maxval=90, group=mtp_group)
tp4_percent = input.float(2.5, "Profit Percent for 4 TP (%)", minval=0.1, maxval=25.0, step=0.1, group=mtp_group)
tp4_qty = input.int(100, "Value of 4 TP (%) (Always All Remained)", minval=10, maxval=100, group=mtp_group)

// ===============================
// TRAILING STOP
// ===============================
trailing_group = "======== TRAILING STOP ========"
use_trailing_stop = input.bool(false, "Use Trailing Stop ? Read Warning ->", group=trailing_group)
visualise_trailing = input.bool(false, "Visualise Trailing Activation Price ?", group=trailing_group)
trailing_activation = input.float(1.5, "Activate Trailing Stop at %", minval=0.1, maxval=10.0, step=0.1, group=trailing_group)
trailing_distance = input.float(0.2, "Distance %", minval=0.1, maxval=5.0, step=0.1, group=trailing_group)

// ===============================
// INDENT ORDER
// ===============================
indent_group = "======== INDENT ORDER ========"
use_indent_order = input.bool(false, "Use Indent Order ?", group=indent_group)
show_last_signal_lines = input.bool(false, "Show Last Signal Lines ?", group=indent_group)
indent_percent = input.float(0.02, "Indent in % (+ or -) (0.02)", minval=-2.0, maxval=2.0, step=0.01, group=indent_group)
cancel_indent_bars = input.int(15, "Cancel Indent Order (if not executed) After X Bars", minval=1, maxval=50, group=indent_group)

// ===============================
// ATR STOP LOSS
// ===============================
atr_sl_group = "======== ATR STOP LOSS ========"
use_atr_sl = input.bool(false, "Use ATR Stop Loss ?", group=atr_sl_group)
atr_sl_wicks = input.bool(false, "ATR SL work on Wicks ? Warning. Read ->", group=atr_sl_group)
atr_sl_method = input.string("WMA", "ATR SL Smoothing Method", options=["SMA", "EMA", "WMA"], group=atr_sl_group)
atr_sl_period = input.int(150, "ATR SL Smoothing Period (150)", minval=1, maxval=500, group=atr_sl_group)
atr_sl_multiplier = input.float(4.0, "Size of ATR SL (Multiplier*ATR) (4)", minval=0.5, maxval=10.0, step=0.1, group=atr_sl_group)

// ===============================
// ATR TAKE PROFIT
// ===============================
atr_tp_group = "======== ATR TAKE PROFIT ========"
use_atr_tp = input.bool(false, "Use ATR Take Profit ?", group=atr_tp_group)
atr_tp_wicks = input.bool(false, "ATR TP work on Wicks ? Warning. Read ->", group=atr_tp_group)
atr_tp_method = input.string("WMA", "ATR TP Smoothing Method", options=["SMA", "EMA", "WMA"], group=atr_tp_group)
atr_tp_period = input.int(150, "ATR TP Smoothing Period (150)", minval=1, maxval=500, group=atr_tp_group)
atr_tp_multiplier = input.float(4.0, "Size of ATR TP (Multiplier*ATR) (4)", minval=0.5, maxval=10.0, step=0.1, group=atr_tp_group)

// ===============================
// PYRAMIDING (MULTI-ORDERS) OPTIONS
// ===============================
pyramiding_group = "======== PYRAMIDING (MULTI-ORDERS) OPTIONS ========"
use_min_distance = input.bool(false, "Use Min Distance for Orders (if Pyramiding is Active) ?", group=pyramiding_group)
min_distance_pyramiding = input.float(0.5, "Min Distance for Pyramiding (%)", minval=0.1, maxval=5.0, step=0.1, group=pyramiding_group)

// ===============================
// ATR VOLATILITY - [FILTER]
// ===============================
atr_vol_group = "======== ATR VOLATILITY - [FILTER] ========"
use_atr_filter = input.bool(false, "Use ATR1 <> ATR2 ?", group=atr_vol_group)
atr1_to_atr2 = input.string("ATR1 < ATR2", "ATR1 to ATR2", options=["ATR1 < ATR2", "ATR1 > ATR2"], group=atr_vol_group)
atr_threshold = input.float(10, "How ATR1 > (<) ATR2. More than XX%", minval=1, maxval=100, step=1, group=atr_vol_group)
atr_length1 = input.int(20, "ATR length1 (20)(5)", minval=1, maxval=200, group=atr_vol_group)
atr_length2 = input.int(100, "ATR length2 (100)(20)", minval=1, maxval=200, group=atr_vol_group)
atr_smoothing = input.string("WMA", "ATR Smoothing", options=["SMA", "EMA", "WMA"], group=atr_vol_group)

// ===============================
// VOLUME [FILTER]
// ===============================
volume_group = "======== VOLUME [FILTER] ========"
use_vol_filter = input.bool(true, "Use VOL1 <> VOL2 ?", group=volume_group)
vol1_to_vol2 = input.string("VOL1 < VOL2", "VOL1 to VOL2", options=["VOL1 < VOL2", "VOL1 > VOL2"], group=volume_group)
vol_threshold = input.float(10, "How VOL1 > (<) VOL2. More than XX%", minval=1, maxval=100, step=1, group=volume_group)
vol_length1 = input.int(20, "VOL length1 (20)(5)", minval=1, maxval=200, group=volume_group)
vol_length2 = input.int(100, "VOL length2 (100)(20)", minval=1, maxval=200, group=volume_group)
vol_smoothing = input.string("WMA", "VOL Smoothing", options=["SMA", "EMA", "WMA"], group=volume_group)

// ===============================
// HIGHEST LOWEST BAR - [SIGNALS]
// ===============================
highlow_group = "======== HIGHEST LOWEST BAR - [SIGNALS] ========"
use_highlow_bar = input.bool(true, "Use Highest/Lowest Bar ?", group=highlow_group)
highlow_period = input.int(10, "Is now Highest/Lowest Bar for last XX bars ?", minval=1, maxval=200, group=highlow_group)
highlow_price_more = input.float(0, "More/Less: Price on (%)", minval=0, maxval=10, step=0.1, group=highlow_group, inline="price_atr")
highlow_atr_more = input.float(0, "ATR on (%)", minval=0, maxval=10, step=0.1, group=highlow_group, inline="price_atr")
highlow_atr_length = input.int(50, "ATR_HL Lenght (50)", minval=1, maxval=200, group=highlow_group)

// ===============================
// BLOCK IF WORSE THAN [FILTER]
// ===============================
block_group = "======== BLOCK IF WORSE THAN [FILTER] ========"
use_block_worse = input.bool(false, "Use Block if Worse Than ?", group=block_group)
block_worse_threshold = input.float(1.1, "Block if worse than XX%", minval=0.1, maxval=10.0, step=0.1, group=block_group)

// ===============================
// SUPER TREND [FILTER]
// ===============================
st_group = "======== SUPER TREND [FILTER] ========"
use_supertrend = input.bool(false, "Use SuperTrend ?", group=st_group)
opposite_st_signal = input.bool(false, "Opposite SP Signal? (Sell on UPtrend..)", group=st_group)
show_supertrend = input.bool(false, "Show SuperTrend ?", group=st_group)
st_period = input.int(10, "SuperTrend ATR Period", minval=1, maxval=50, group=st_group)
st_multiplier = input.float(3, "SuperTrend ATR Multiplier", minval=0.5, maxval=10.0, step=0.1, group=st_group)
st_timeframe = input.timeframe("Chart", "SuperTrend TimeFrame:", group=st_group)

// ===============================
// SUPER TREND [FILTER] (TF2)
// ===============================
st2_group = "======== SUPER TREND [FILTER] (TF2) ========"
use_supertrend2 = input.bool(false, "Use SuperTrend (TF2) ?", group=st2_group)
opposite_st2_signal = input.bool(false, "Opposite SP (TF2) Signal?", group=st2_group)
show_supertrend2 = input.bool(false, "Show SuperTrend (TF2) ?", group=st2_group)
st2_period = input.int(10, "SuperTrend ATR Period (TF2)", minval=1, maxval=50, group=st2_group)
st2_multiplier = input.float(3, "SuperTrend ATR Multiplier (TF2)", minval=0.5, maxval=10.0, step=0.1, group=st2_group)
st2_timeframe = input.timeframe("1 hour", "SuperTrend (TF2) TimeFrame:", group=st2_group)

// ===============================
// ACCUMULATION AREAS - [FILTER] OR [SIGNAL]
// ===============================
acc_group = "===== ACCUMULATION AREAS - [FILTER] OR [SIGNAL] ====="
use_accumulation = input.bool(false, "Use Accumulation Areas ?", group=acc_group)
acc_backtrack = input.int(30, "Backtracking Interval", minval=5, maxval=100, group=acc_group)
acc_min_bars = input.int(5, "Min Bars to Execute Order", minval=1, maxval=50, group=acc_group)
acc_breakout_signal = input.bool(false, "Signal on Accumulation BreakOut ?", group=acc_group)
acc_breakout_opposite = input.bool(false, "Signal on BreakOut-Opposute Direction ?", group=acc_group)

// ===============================
// TWO MAS NEW [SIGNALS AND FILTER]
// ===============================
ma_group = "=========== TWO MAS NEW [SIGNALS AND FILTER] =============="
ma1_length = input.int(50, "Moving Average 1 length (50)", minval=2, maxval=200, group=ma_group)
ma1_type = input.string("SMA", "MA 1 Smoothing Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma1_source = input.source(close, "MA1 Source", group=ma_group)
ma2_length = input.int(100, "Moving Average 1 length (100)", minval=2, maxval=200, group=ma_group)
ma2_type = input.string("EMA", "MA 2 Smoothing Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma2_source = input.source(close, "MA2 Source", group=ma_group)
show_two_mas = input.bool(false, "Show TWO MAs. (MA1 - green, MA2 - red)", group=ma_group)
ma_timeframe = input.timeframe("Not Active", "TWO MAs TimeFrame:", group=ma_group)

use_ma_cross = input.bool(false, "======= Use MA1 / MA2 Cross =======", group=ma_group)
opposite_ma_cross = input.bool(false, "Opposite Signal - \"MA1 / MA2 Cross\"", group=ma_group)
activate_ma_memory = input.bool(false, "Activate \"MA1 / MA2 Cross\" Signal Memory", group=ma_group)
ma_memory_bars = input.int(5, "Keep \"MA1 / MA2 Cross\" Signal Memory for XX bars", minval=1, maxval=50, group=ma_group)
use_ma1_filter = input.bool(false, "===== Use MA1 as Filter. Long if Price > MA 1 =====", group=ma_group)
opposite_ma1_filter = input.bool(false, "Opposite Signal - \"MA1 as Filter\"", group=ma_group)

// ===============================
// KELTNER/BOLLINGER CHANNEL - [FILTER]
// ===============================
channel_group = "======== KELTNER/BOLLINGER CHANNEL - [FILTER] ========"
use_channel = input.bool(false, "Use Channel ?", group=channel_group)
channel_timeframe = input.timeframe("Chart", "Channel TimeFrame:", group=channel_group)
channel_rebound = input.string("Rebound", "BB/KC Channel Breackout or Rebound from bands:", options=["Rebound", "Breakout"], group=channel_group)
channel_type = input.string("Keltner Channel", "Channel to Use:", options=["Keltner Channel", "Bollinger Bands"], group=channel_group)
channel_conditions = input.string("Wick out of bands", "Enter Conditions", options=["Wick out of bands", "Close out of bands"], group=channel_group)

keltner_length = input.int(14, "Keltner Long.", minval=1, maxval=100, group=channel_group, inline="keltner")
keltner_mult = input.float(1.5, "Keltner Mult.", minval=0.1, maxval=10.0, step=0.1, group=channel_group, inline="keltner")
bb_length = input.int(20, "BB Long.", minval=1, maxval=100, group=channel_group, inline="bb")
bb_deviation = input.float(2, "BB Deviation (Desv.)", minval=0.1, maxval=10.0, step=0.1, group=channel_group, inline="bb")

// ===============================
// RSI - [IN RANGE FILTER OR CROSS SIGNAL]
// ===============================
rsi_group = "======== RSI - [IN RANGE FILTER OR CROSS SIGNAL] ========"
rsi_length = input.int(14, "RSI TF Long(14):", minval=2, maxval=100, group=rsi_group)
rsi_timeframe = input.timeframe("Chart", "RSI TimeFrame:", group=rsi_group)

use_rsi_long_range = input.bool(false, "Use RSI LONG Range", group=rsi_group)
rsi_long_more = input.int(1, "(LONG) RSI is More", minval=0, maxval=100, group=rsi_group, inline="rsi_long")
rsi_long_less = input.int(50, "& RSI Less", minval=0, maxval=100, group=rsi_group, inline="rsi_long")

use_rsi_short_range = input.bool(false, "Use RSI SHORT Range", group=rsi_group)
rsi_short_less = input.int(100, "(SHORT) RSI is Less", minval=0, maxval=100, group=rsi_group, inline="rsi_short")
rsi_short_more = input.int(50, "& RSI More", minval=0, maxval=100, group=rsi_group, inline="rsi_short")

use_rsi_cross = input.bool(false, "Use RSI Cross Level", group=rsi_group)
rsi_long_level = input.int(30, "Level to Cross RSI for LONG", minval=0, maxval=100, group=rsi_group)
rsi_short_level = input.int(70, "Level to Cross RSI for SHORT", minval=0, maxval=100, group=rsi_group)
opposite_rsi_cross = input.bool(false, "Opposite Signal - RSI Cross Level", group=rsi_group)
activate_rsi_memory = input.bool(false, "Activate RSI Cross Signal Memory", group=rsi_group)
rsi_memory_bars = input.int(5, "Keep RSI Cross Signal Memory for XX bars", minval=1, maxval=50, group=rsi_group)

// ===============================
// STOCHASTIC - [RANGE FILTER OR CROSS SIGNAL]
// ===============================
stoch_group = "==== STOCHASTIC - [RANGE FILTER OR CROSS SIGNAL] ===="
stoch_k_length = input.int(14, "Stochastic %K Length (14)", minval=1, maxval=100, group=stoch_group)
stoch_k_smooth = input.int(3, "Stochastic %K Smoothing (3)", minval=1, maxval=10, group=stoch_group)
stoch_d_smooth = input.int(3, "Stochastic %D Smoothing (3)", minval=1, maxval=10, group=stoch_group)
stoch_timeframe = input.timeframe("Not Active", "Stochastic TimeFrame:", group=stoch_group)

use_stoch_range_filter = input.bool(false, "======= Use Stochastic Range Filter =======", group=stoch_group)
stoch_long_more = input.int(1, "(LONG) Stoch %D is More", minval=0, maxval=100, group=stoch_group, inline="stoch_long")
stoch_long_less = input.int(50, "& Stoch %D Less", minval=0, maxval=100, group=stoch_group, inline="stoch_long")
stoch_short_less = input.int(100, "(SHORT) Stoch %D is Less", minval=0, maxval=100, group=stoch_group, inline="stoch_short")
stoch_short_more = input.int(50, "& Stoch %D More", minval=0, maxval=100, group=stoch_group, inline="stoch_short")

use_stoch_cross_level = input.bool(false, "======= Use Stochastic Cross Level =======", group=stoch_group)
stoch_long_level = input.int(20, "Level to Cross Stochastic for LONG", minval=0, maxval=100, group=stoch_group)
stoch_short_level = input.int(80, "Level to Cross Stochastic for SHORT", minval=0, maxval=100, group=stoch_group)
activate_stoch_cross_memory = input.bool(false, "Activate Stochastic Cross Signal Memory", group=stoch_group)
stoch_cross_memory_bars = input.int(5, "Keep Stochastic Cross Signal Memory for XX Bars", minval=1, maxval=50, group=stoch_group)

use_stoch_kd_cross = input.bool(false, "======= Use Stochastic Cross K/D =======", group=stoch_group)
opposite_stoch_kd = input.bool(false, "Opposite Signal - Stochastic Cross K/D", group=stoch_group)
activate_stoch_kd_memory = input.bool(false, "Activate Stochastic Cross K/D Signal Memory", group=stoch_group)
stoch_kd_memory_bars = input.int(5, "Keep Stochastic Cross K/D Signal Memory for XX bars", minval=1, maxval=50, group=stoch_group)

// ===============================
// RVI - RELATIVE VOLATILITY INDEX [FILTER]
// ===============================
rvi_group = "======== RVI - RELATIVE VOLATILITY INDEX [FILTER] ========"
rvi_length = input.int(10, "RVI Long(10):", minval=2, maxval=100, group=rvi_group)
rvi_timeframe = input.timeframe("Chart", "RVI TimeFrame:", group=rvi_group)
rvi_type = input.string("WMA", "RVI MA Type", options=["SMA", "EMA", "WMA"], group=rvi_group)
rvi_ma_length = input.int(2, "RVI MA Length(2)", minval=1, maxval=50, group=rvi_group)

use_rvi_long_range = input.bool(false, "Use RVI LONG Range", group=rvi_group)
rvi_long_more = input.int(1, "(LONG) RVI is More", minval=0, maxval=100, group=rvi_group, inline="rvi_long")
rvi_long_less = input.int(50, "& RVI Less", minval=0, maxval=100, group=rvi_group, inline="rvi_long")

use_rvi_short_range = input.bool(false, "Use RVI SHORT Range", group=rvi_group)
rvi_short_less = input.int(100, "(SHORT) RVI is Less", minval=0, maxval=100, group=rvi_group, inline="rvi_short")
rvi_short_more = input.int(50, "& RVI More", minval=0, maxval=100, group=rvi_group, inline="rvi_short")

// ===============================
// MONEY FLOW INDEX [FILTER]
// ===============================
mfi_group = "======== MONEY FLOW INDEX [FILTER] ========"
mfi_length = input.int(14, "MFI TF Long:", minval=2, maxval=100, group=mfi_group)
mfi_timeframe = input.timeframe("Chart", "MFI TimeFrame:", group=mfi_group)

use_mfi_long_range = input.bool(false, "Use MFI LONG Range", group=mfi_group)
mfi_long_more = input.int(1, "(LONG) MFI is More", minval=0, maxval=100, group=mfi_group, inline="mfi_long")
mfi_long_less = input.int(60, "& MFI Less", minval=0, maxval=100, group=mfi_group, inline="mfi_long")

use_mfi_short_range = input.bool(false, "Use MFI SHORT Range", group=mfi_group)
mfi_short_less = input.int(100, "(SHORT) MFI is Less", minval=0, maxval=100, group=mfi_group, inline="mfi_short")
mfi_short_more = input.int(50, "& MFI More", minval=0, maxval=100, group=mfi_group, inline="mfi_short")

// ===============================
// CCI - [FILTER]
// ===============================
cci_group = "======== CCI - [FILTER] ========"
cci_length = input.int(14, "CCI TF Long(14):", minval=2, maxval=200, group=cci_group)
cci_timeframe = input.timeframe("Chart", "CCI TimeFrame:", group=cci_group)

use_cci_long_range = input.bool(false, "Use CCI LONG Range (-400:400)", group=cci_group)
cci_long_more = input.int(-400, "(LONG) CCI is More", minval=-1000, maxval=1000, group=cci_group, inline="cci_long")
cci_long_less = input.int(400, "& CCI Less", minval=-1000, maxval=1000, group=cci_group, inline="cci_long")

use_cci_short_range = input.bool(false, "Use CCI SHORT Range (400:-400)", group=cci_group)
cci_short_less = input.int(400, "(SHORT) CCI is Less", minval=-1000, maxval=1000, group=cci_group, inline="cci_short")
cci_short_more = input.int(10, "& CCI More", minval=-1000, maxval=1000, group=cci_group, inline="cci_short")

// ===============================
// PIVOT LEVELS - [SIGNALS] [FILTER]
// ===============================
pivot_group = "========= PIVOT LEVELS - [SIGNALS] [FILTER] =========="
pivot_timeframe = input.timeframe("1 hour", "LEVELS TimeFrame:", group=pivot_group)
pivot_left = input.int(10, "Pivot Left Bars", minval=1, maxval=50, group=pivot_group)
pivot_right = input.int(5, "Pivot Right Bars", minval=1, maxval=50, group=pivot_group)
pivot_limit = input.int(6, "Number of Levels Limit", minval=1, maxval=20, group=pivot_group)

open_near_level = input.bool(false, "Open Long/Short if Support/Resistance Level is Near", group=pivot_group)
near_distance_execute = input.float(0.05, "How far is \"Near\" % (to execute order)", minval=0.01, maxval=10.0, step=0.01, group=pivot_group)

not_open_near_level = input.bool(false, "Not Open Long/Short if Resistance/Support Level is Near", group=pivot_group)
near_distance_block = input.float(0.5, "How far is \"Near\" % (to Block execution of order)", minval=0.01, maxval=10.0, step=0.01, group=pivot_group)

close_near_level = input.bool(false, "CLOSE Long/Short if Resistance/Support Level is Near", group=pivot_group)
near_distance_close = input.float(0.5, "How far is \"Near\" % (to CLOSE the order)", minval=0.01, maxval=10.0, step=0.01, group=pivot_group)
close_profit_only = input.bool(false, "Close on Level only with Profit ?", group=pivot_group)
min_profit_close = input.float(1, "Min Profit percent for Close on Level. %%", minval=0.1, maxval=10.0, step=0.1, group=pivot_group)

// ===============================
// MACD - [SIGNALS] (CROSS 0 LINE OR CROSS SIGNAL LINE)
// ===============================
macd_group = "=== MACD - [SIGNALS] (CROSS 0 LINE OR CROSS SIGNAL LINE ==="
enable_macd_visual = input.bool(false, "Enable Visualisation MACD", group=macd_group)
macd_fast = input.int(12, "MACD Fast Length (12)", minval=1, maxval=50, group=macd_group)
macd_slow = input.int(26, "MACD Slow Length (26)", minval=5, maxval=100, group=macd_group)
macd_signal = input.int(9, "MACD Signal Smoothing (9)", minval=1, maxval=50, group=macd_group)
macd_source = input.source(close, "MACD Source", group=macd_group)

use_macd_cross_level = input.bool(false, "Use MACD Cross with Level (0)", group=macd_group)
opposite_macd_level = input.bool(false, "Opposite Signal - MACD Cross with Level (0)", group=macd_group)
macd_cross_level = input.float(0, "Cross Line Level (0)", group=macd_group)

use_macd_cross_signal = input.bool(false, "Use MACD Cross with Signal Line", group=macd_group)
opposite_macd_signal = input.bool(false, "Opposite Signal - MACD Cross with Signal Line", group=macd_group)
disable_macd_memory = input.bool(false, "==Disable Signal Memory (for both MACD Crosses )==", group=macd_group)

// ===============================
// LINEAR REGRESSION CHANNEL [SIGNALS]
// ===============================
lrc_group = "======= LINEAR REGRESSION CHANNEL [SIGNALS] ======="
use_lrc = input.bool(false, "Use Linear Regression Channel SIGNALS?", group=lrc_group)
disable_lrc_memory = input.bool(false, "Disable LRC Signal Memory", group=lrc_group)
lrc_memory_bars = input.int(5, "Keep LRC Signal Memory for XX Bars", minval=1, maxval=50, group=lrc_group)
lrc_rebound_breakout = input.string("Rebound", "Channel Breackout or Rebound from bands:", options=["Rebound", "Breakout"], group=lrc_group)
lrc_slope_direction = input.string("Allow_All", "Use Slope Direction ?", options=["Allow_All", "Only_UP", "Only_DOWN"], group=lrc_group)
lrc_source = input.source(close, "LRC Source", group=lrc_group)
lrc_length = input.int(20, "LRC Length", minval=5, maxval=200, group=lrc_group)
lrc_deviation = input.float(2.3, "LRC Deviation", minval=0.1, maxval=10.0, step=0.1, group=lrc_group)

// ===============================
// EXTERNAL INDICATOR [FILTER]
// ===============================
external_group = "======== EXTERNAL INDICATOR [FILTER] ========"
external1_source = input.source(close, "External Indicator 1 (EXT1)", group=external_group)
external2_source = input.source(close, "External indicator 2 (EXT2)", group=external_group)

use_external_longs = input.bool(false, "======= Use External Indicator for Longs ? =======", group=external_group)
ext1a_condition = input.string("==", "EXT1a:", options=["==", "!=", ">", "<", ">=", "<="], group=external_group, inline="ext1a")
ext1a_compare = input.string("Value", ":A", options=["Value", "EXT2"], group=external_group, inline="ext1a") 
ext1a_value = input.float(0, "Value_L_1:", group=external_group, inline="ext1a")

use_ext2_longs = input.bool(false, "AND (optionally) use #2 condition External Indicator for Longs ?", group=external_group)
ext1b_condition = input.string("==", "EXT1b:", options=["==", "!=", ">", "<", ">=", "<="], group=external_group, inline="ext1b")
ext1b_compare = input.string("Value", ":B", options=["Value", "EXT2"], group=external_group, inline="ext1b")
ext1b_value = input.float(0, "Value_L_2:", group=external_group, inline="ext1b")

use_ext3_longs = input.bool(false, "AND (optionally) use #3 condition with External_Indicator_2 for Longs ?", group=external_group)
ext2c_condition = input.string("==", "EXT2c:", options=["==", "!=", ">", "<", ">=", "<="], group=external_group, inline="ext2c")
ext2c_compare = input.string("Value", ":C", options=["Value", "EXT1"], group=external_group, inline="ext2c")
ext2c_value = input.float(0, "Value_L_3:", group=external_group, inline="ext2c")

use_external_shorts = input.bool(false, "======= Use External Indicator for Shorts ? =======", group=external_group)
ext1d_condition = input.string("==", "EXT1d:", options=["==", "!=", ">", "<", ">=", "<="], group=external_group, inline="ext1d")
ext1d_compare = input.string("Value", ":D", options=["Value", "EXT2"], group=external_group, inline="ext1d")
ext1d_value = input.float(0, "Value_S_1:", group=external_group, inline="ext1d")

use_ext2_shorts = input.bool(false, "AND (optionally) use #2 condition External Indicator for Shorts ?", group=external_group)
ext1e_condition = input.string("==", "EXT1e:", options=["==", "!=", ">", "<", ">=", "<="], group=external_group, inline="ext1e")
ext1e_compare = input.string("Value", ":E", options=["Value", "EXT2"], group=external_group, inline="ext1e")
ext1e_value = input.float(0, "Value_S_2:", group=external_group, inline="ext1e")

use_ext3_shorts = input.bool(false, "AND (optionally) use #3 condition with External_Indicator_2 for Short ?", group=external_group)
ext2f_condition = input.string("==", "EXT2f:", options=["==", "!=", ">", "<", ">=", "<="], group=external_group, inline="ext2f")
ext2f_compare = input.string("Value", ":F", options=["Value", "EXT1"], group=external_group, inline="ext2f")
ext2f_value = input.float(0, "Value_S_3:", group=external_group, inline="ext2f")

// ===============================
// DMI [FILTER]
// ===============================
dmi_group = "======== DMI [FILTER] ========"
dmi_period = input.int(14, "DI Period Length (14):", minval=1, maxval=100, group=dmi_group)
adx_smooth_period = input.int(14, "ADX Smoothing Period (14):", minval=1, maxval=100, group=dmi_group)
dmi_timeframe = input.timeframe("Chart", "DMI TimeFrame:", group=dmi_group)
visualise_dmi = input.bool(false, "Visualise DMI Lines ?", group=dmi_group)
dmi_long_line = input.string("DI+", "For Longs using DMI Line:", options=["DI+", "DI-", "ADX"], group=dmi_group)
dmi_short_line = input.string("DI+", "For Shorts using DMI Line:", options=["DI+", "DI-", "ADX"], group=dmi_group)

use_dmi_long_range = input.bool(false, "Use DMI LONG Range (1:50)", group=dmi_group)
dmi_long_more = input.int(15, "(LONG) DMI is More", minval=0, maxval=100, group=dmi_group, inline="dmi_long")
dmi_long_less = input.int(50, "& DMI Less", minval=0, maxval=100, group=dmi_group, inline="dmi_long")

use_dmi_short_range = input.bool(false, "Use DMI SHORT Range (50:1)", group=dmi_group)
dmi_short_less = input.int(50, "(SHORT) DMI is Less", minval=0, maxval=100, group=dmi_group, inline="dmi_short")
dmi_short_more = input.int(15, "& DMI More", minval=0, maxval=100, group=dmi_group, inline="dmi_short")

// ===============================
// CHAIKIN MONEY FLOW - [SIGNALS CROSS] OR [FILTER]
// ===============================
cmf_group = "=== CHAIKIN MONEY FLOW - [SIGNALS CROSS] OR [FILTER] ==="
cmf_period = input.int(21, "Chaikin Money Flow period(21):", minval=1, maxval=100, group=cmf_group)
cmf_timeframe = input.timeframe("Chart", "Chaikin Money Flow TimeFrame:", group=cmf_group)

use_cmf_cross = input.bool(false, "Use CMF Cross with Line", group=cmf_group)
disable_cmf_memory = input.bool(false, "Disable CMF Cross Signal Memory", group=cmf_group)
cmf_cross_level = input.float(0, "Cross Line Level", group=cmf_group)

use_cmf_long_range = input.bool(false, "Use CMF LONG Range (-100:100)", group=cmf_group)
cmf_long_more = input.int(-50, "(LONG) CMF is More", minval=-100, maxval=100, group=cmf_group, inline="cmf_long")
cmf_long_less = input.int(50, "& CMF Less", minval=-100, maxval=100, group=cmf_group, inline="cmf_long")

use_cmf_short_range = input.bool(false, "Use CMF SHORT Range (100:-100)", group=cmf_group)
cmf_short_less = input.int(50, "(SHORT) CMF is Less", minval=-100, maxval=100, group=cmf_group, inline="cmf_short")
cmf_short_more = input.int(-50, "& CMF More", minval=-100, maxval=100, group=cmf_group, inline="cmf_short")

// ===============================
// BALANCE OF POWER - [SIGNALS CROSS] OR [FILTER]
// ===============================
bop_group = "=== BALANCE OF POWER - [SIGNALS CROSS] OR [FILTER] ==="
bop_smooth_length = input.int(15, "BOP Smooth Length(15):", minval=1, maxval=100, group=bop_group)
triple_bop_length = input.int(14, "TRIPLE BOP Smooth Length(14)", minval=1, maxval=100, group=bop_group)
bop_timeframe = input.timeframe("Chart", "Balance of Power TimeFrame:", group=bop_group)

use_bop_cross = input.bool(false, "Use BOP Cross with Line", group=bop_group)
disable_bop_memory = input.bool(false, "Disable BOP Cross Signal Memory", group=bop_group)
bop_cross_level = input.float(0, "Cross Line Level", group=bop_group)

use_bop_long_range = input.bool(false, "Use BOP LONG Range (-100:100)", group=bop_group)
bop_long_more = input.int(-50, "(LONG) BOP is More", minval=-100, maxval=100, group=bop_group, inline="bop_long")
bop_long_less = input.int(50, "& BOP Less", minval=-100, maxval=100, group=bop_group, inline="bop_long")

use_bop_short_range = input.bool(false, "Use BOP SHORT Range (100:-100)", group=bop_group)
bop_short_less = input.int(50, "(SHORT) BOP is Less", minval=-100, maxval=100, group=bop_group, inline="bop_short")
bop_short_more = input.int(-50, "& BOP More", minval=-100, maxval=100, group=bop_group, inline="bop_short")

// ===============================
// SMIO - [FILTER]
// ===============================
smio_group = "========= SMIO - [FILTER] ========="
smio_short_length = input.int(5, "SMIO Short Length(5)", minval=1, maxval=100, group=smio_group)
smio_long_length = input.int(20, "SMIO Long Length(20)", minval=1, maxval=100, group=smio_group)
smio_signal_length = input.int(5, "SMIO Signal Line Length(5)", minval=1, maxval=100, group=smio_group)
smio_timeframe = input.timeframe("Chart", "SMIO TimeFrame:", group=smio_group)

use_smio_long_range = input.bool(false, "Use SMIO LONG Range (-100:100)", group=smio_group)
smio_long_more = input.int(-50, "(LONG) SMIO is More", minval=-100, maxval=100, group=smio_group, inline="smio_long")
smio_long_less = input.int(70, "& SMIO Less", minval=-100, maxval=100, group=smio_group, inline="smio_long")

use_smio_short_range = input.bool(false, "Use SMIO SHORT Range (100:-100)", group=smio_group)
smio_short_less = input.int(70, "(SHORT) SMIO is Less", minval=-100, maxval=100, group=smio_group, inline="smio_short")
smio_short_more = input.int(-50, "& SMIO More", minval=-100, maxval=100, group=smio_group, inline="smio_short")

// ===============================
// QQE [SIGNALS]
// ===============================
qqe_group = "=============== QQE [SIGNALS] ================"
use_qqe = input.bool(false, "Use QQE ?", group=qqe_group)
opposite_qqe = input.bool(false, "Opposite QQE ?", group=qqe_group)
enable_qqe_visual = input.bool(false, "Enable QQE Visualisation", group=qqe_group)
disable_qqe_memory = input.bool(false, "Disable QQE Signal Memory", group=qqe_group)
qqe_rsi_length = input.int(14, "QQE RSI Length(14)", minval=2, maxval=100, group=qqe_group)
qqe_rsi_smooth = input.int(5, "QQE RSI Smoothing(5)", minval=1, maxval=50, group=qqe_group)
qqe_delta_mult = input.float(5.1, "Delta Multiplier(5.1)", minval=0.1, maxval=20.0, step=0.1, group=qqe_group)

// ===============================
// DIVERGENCE [SIGNALS]
// ===============================
div_group = "====== DIVERGENCE [SIGNALS] ======"
use_divergence = input.bool(false, "Use Divergence ?", group=div_group)
div_pivot_interval = input.int(9, "Pivot Interval(9)", minval=2, maxval=50, group=div_group)
div_act_without_conf = input.bool(false, "Act Without Confirmation", group=div_group)
show_div_lines = input.bool(false, "Show Divergence Lines", group=div_group)
activate_div_memory = input.bool(false, "Activate DIVER Signal Memory", group=div_group)
div_memory_bars = input.int(5, "Keep DIVER Signal Memory for XX bars", minval=1, maxval=50, group=div_group)

// ===============================
// MOMENTUM - [FILTER]
// ===============================
momentum_group = "========= MOMENTUM - [FILTER] ========="
momentum_tf_long = input.int(14, "Momentum TF Long(14):", minval=1, maxval=100, group=momentum_group)
momentum_timeframe = input.timeframe("Chart", "Momentum TimeFrame:", group=momentum_group)
momentum_source = input.source(close, "Momentum Source", group=momentum_group)

use_momentum_long_range = input.bool(false, "Use Momentum LONG Range (-100:100)", group=momentum_group)
momentum_long_more = input.int(-100, "(LONG) Momentum is More", minval=-200, maxval=200, group=momentum_group, inline="mom_long")
momentum_long_less = input.int(10, "& Mom Less", minval=-200, maxval=200, group=momentum_group, inline="mom_long")

use_momentum_short_range = input.bool(false, "Use Momentum SHORT Range (100:-100)", group=momentum_group)
momentum_short_less = input.int(95, "(SHORT) Momentum is Less", minval=-200, maxval=200, group=momentum_group, inline="mom_short")
momentum_short_more = input.int(-30, "& Mom More", minval=-200, maxval=200, group=momentum_group, inline="mom_short")

// ===============================
// PRICE ACTION - CANDLESTICK PATTERNS [SIGNALS]
// ===============================
candle_group = "======= PRICE ACTION - CANDLESTICK PATTERNS [SIGNALS] ======"
use_candlestick_patterns = input.bool(false, "Use Candlestick Patterns ?", group=candle_group)
mfi_candle_length = input.int(14, "Mfi length(14)", minval=1, maxval=100, group=candle_group)
mfi_obv = input.bool(false, "OBV", group=candle_group, inline="mfi_line")
mfi_index = input.bool(false, "Money Flow Index", group=candle_group, inline="mfi_line")

candle_timeframe = input.timeframe("Not Active", "Price Action TimeFrame", group=candle_group)
disable_candle_memory = input.bool(false, "Disable Candlestick Patterns Signal Memory", group=candle_group)

// Short patterns
dark_cloud_short = input.bool(false, "Dark Cloud Cover (Short)", group=candle_group)
falling_three_short = input.bool(false, "Falling Three Methods (Short)", group=candle_group)
gravestone_doji_short = input.bool(false, "Gravestone Doji (Short)", group=candle_group)
hanging_man_short = input.bool(false, "Hanging Man (Short)", group=candle_group)
long_upper_shadow_short = input.bool(false, "Long Upper Shadow (Short)", group=candle_group)
marubozu_black_short = input.bool(false, "Marubozu Black (Short)", group=candle_group)
shooting_star_short = input.bool(false, "Shooting Star (Short)", group=candle_group)
spinning_top_black_short = input.bool(false, "Spinning Top Black (Short)", group=candle_group)
tweezer_top_short = input.bool(false, "Tweezer Top (Short)", group=candle_group)

// Both direction patterns
doji_both = input.bool(false, "Doji (Short/Long)", group=candle_group)
doji_star_both = input.bool(false, "Doji Star (Short/Long)", group=candle_group)
engulfing_both = input.bool(false, "Engulfing (Short/Long)", group=candle_group)
harami_both = input.bool(false, "Harami (Short/Long)", group=candle_group)

// Long patterns
inverted_hammer_long = input.bool(false, "Inverted Hammer (Long)", group=candle_group)
dragonfly_doji_long = input.bool(false, "Dragonfly Doji (Long)", group=candle_group)
hammer_long = input.bool(false, "Hammer (Long)", group=candle_group)
long_lower_shadow_long = input.bool(false, "Long Lower Shadow (Long)", group=candle_group)
marubozu_white_long = input.bool(false, "Marubozu White (Long)", group=candle_group)
piercing_long = input.bool(false, "Piercing (Long)", group=candle_group)
rising_three_long = input.bool(false, "Rising Three Methods (Long)", group=candle_group)
spinning_top_white_long = input.bool(false, "Spinning Top White (Long)", group=candle_group)
tweezer_bottom_long = input.bool(false, "Tweezer Bottom (Long)", group=candle_group)

// ===============================
// CLOSE CONDITIONS
// ===============================
close_group = "======== CLOSE CONDITION - CLOSE BY RSI ========"
rsi_close_length = input.int(14, "RSI CLOSE Length(14):", minval=2, maxval=100, group=close_group)
rsi_close_timeframe = input.timeframe("Chart", "RSI CLOSE TimeFrame:", group=close_group)

use_rsi_close_long = input.bool(false, "Use RSI CLOSE LONG", group=close_group)
rsi_cl_long_more = input.int(60, "(LONG) RSI_CL is More", minval=0, maxval=100, group=close_group, inline="rsi_close_long")
rsi_cl_long_less = input.int(100, "& RSI_CL Less", minval=0, maxval=100, group=close_group, inline="rsi_close_long")

use_rsi_close_short = input.bool(false, "Use RSI CLOSE SHORT", group=close_group)
rsi_cl_short_less = input.int(40, "(SHORT) RSI_CL is Less", minval=0, maxval=100, group=close_group, inline="rsi_close_short")
rsi_cl_short_more = input.int(1, "& RSI_CL More", minval=0, maxval=100, group=close_group, inline="rsi_close_short")

close_rsi_profit_only = input.bool(false, "Close by RSI only with Profit ?", group=close_group)
min_profit_rsi_close = input.float(1, "Min Profit percent for Close by RSI. %%", minval=0.1, maxval=10.0, step=0.1, group=close_group)

// Additional close conditions
use_lrc_close = input.bool(false, "Use \"LRC Length\" from SIGNALS settings above ?", group=close_group)
lrc_close_deviation = input.float(2.3, "LRC Deviation CLOSE", minval=0.1, maxval=10.0, step=0.1, group=close_group)
show_lrc_extend_close = input.bool(false, "Show LRC Extend Lines CLOSE", group=close_group)
show_broken_lrc_close = input.bool(false, "Show Broken LRC Channel CLOSE", group=close_group)

// Close by time
use_close_time = input.bool(false, "Use Close By Time Since Order ?", group=close_group)
close_after_bars = input.int(10, "Close order after XX bars:", minval=1, maxval=100, group=close_group)
close_time_profit_only = input.bool(false, "Close only with Profit ?", group=close_group)
min_profit_time_close = input.float(0.5, "Min Profit percent for Close. %%", minval=0.1, maxval=10.0, step=0.1, group=close_group)

// Input values section
input_values_group = "INPUT VALUES"
inputs_in_status = input.bool(true, "Inputs in status line", group=input_values_group)

// ===============================
// HELPER FUNCTIONS
// ===============================
f_security(_sym, _res, _src, _rep) =>
    request.security(_sym, _res, _src[not _rep and barstate.isrealtime ? 1 : 0])[_rep or barstate.isrealtime ? 0 : 1]

smoothing_func(src, length, smoothing_type) =>
    switch smoothing_type
        "SMA" => ta.sma(src, length)
        "EMA" => ta.ema(src, length)
        "WMA" => ta.wma(src, length)
        => ta.sma(src, length)

ma_func(src, length, ma_type) =>
    switch ma_type
        "SMA" => ta.sma(src, length)
        "EMA" => ta.ema(src, length)
        "RMA" => ta.rma(src, length)
        "WMA" => ta.wma(src, length)
        "HMA" => ta.hma(src, length)
        "VWMA" => ta.vwma(src, length)
        "TEMA" => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            ema3 = ta.ema(ema2, length)
            3 * (ema1 - ema2) + ema3
        "DEMA" => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            2 * ema1 - ema2
        => ta.ema(src, length)

// SuperTrend calculation
supertrend_calc(atr_period, multiplier) =>
    atr = ta.atr(atr_period)
    hl2_price = hl2
    
    upperband = hl2_price + (multiplier * atr)
    lowerband = hl2_price - (multiplier * atr)
    
    ub = nz(upperband[1], upperband)
    lb = nz(lowerband[1], lowerband)
    
    ub := lowerband > ub[1] ? lowerband : ub
    lb := upperband < lb[1] ? upperband : lb
    
    var int trend = 1
    trend := close > ub[1] ? 1 : close < lb[1] ? -1 : nz(trend[1], 1)
    
    supertrend = trend == 1 ? lb : ub
    [supertrend, trend]

// Compare function for external indicators
compare_values(value1, condition, value2) =>
    switch condition
        "==" => value1 == value2
        "!=" => value1 != value2
        ">" => value1 > value2
        "<" => value1 < value2
        ">=" => value1 >= value2
        "<=" => value1 <= value2
        => false

// ===============================
// CALCULATIONS
// ===============================

// Time filter
date_filter = timestamp(start_year, start_month, start_day, 0, 0) <= time and time <= timestamp(stop_year, stop_month, stop_day, 23, 59)
day_blocked = (block_sunday and dayofweek == dayofweek.sunday) or 
              (block_monday and dayofweek == dayofweek.monday) or 
              (block_tuesday and dayofweek == dayofweek.tuesday) or 
              (block_wednesday and dayofweek == dayofweek.wednesday) or 
              (block_thursday and dayofweek == dayofweek.thursday) or 
              (block_friday and dayofweek == dayofweek.friday) or 
              (block_saturday and dayofweek == dayofweek.saturday)
time_trade_allowed = date_filter and not day_blocked

// ATR Volatility filter
atr1_calc = smoothing_func(ta.atr(atr_length1), atr_length1, atr_smoothing)
atr2_calc = smoothing_func(ta.atr(atr_length2), atr_length2, atr_smoothing)
atr_diff_percent = math.abs(atr1_calc - atr2_calc) / atr2_calc * 100

atr_filter_passed = true
if use_atr_filter
    if atr1_to_atr2 == "ATR1 < ATR2"
        atr_filter_passed := atr1_calc < atr2_calc and atr_diff_percent >= atr_threshold
    else
        atr_filter_passed := atr1_calc > atr2_calc and atr_diff_percent >= atr_threshold

// Volume calculations
vol1_smoothed = smoothing_func(volume, vol_length1, vol_smoothing)
vol2_smoothed = smoothing_func(volume, vol_length2, vol_smoothing)
vol_diff_percent = math.abs(vol1_smoothed - vol2_smoothed) / vol2_smoothed * 100

vol_filter_passed = true
if use_vol_filter
    if vol1_to_vol2 == "VOL1 < VOL2"
        vol_filter_passed := vol1_smoothed < vol2_smoothed and vol_diff_percent >= vol_threshold
    else
        vol_filter_passed := vol1_smoothed > vol2_smoothed and vol_diff_percent >= vol_threshold

// Highest/Lowest Bar filter
is_highest_bar = high == ta.highest(high, highlow_period)
is_lowest_bar = low == ta.lowest(low, highlow_period)
highlow_atr = ta.atr(highlow_atr_length)

price_condition = true
atr_condition = true

if highlow_price_more > 0
    price_condition := math.abs(close - close[1]) / close[1] * 100 >= highlow_price_more

if highlow_atr_more > 0
    atr_condition := highlow_atr >= ta.atr(14) * (1 + highlow_atr_more / 100)

highlow_filter_passed = true
if use_highlow_bar
    highlow_filter_passed := (is_highest_bar or is_lowest_bar) and price_condition and atr_condition

// Block if worse than filter
block_worse_filter_passed = true
if use_block_worse and strategy.closedtrades > 0
    last_trade_profit_percent = strategy.closedtrades.profit(strategy.closedtrades - 1) / strategy.initial_capital * 100
    block_worse_filter_passed := last_trade_profit_percent >= -block_worse_threshold

// SuperTrend calculations
[supertrend1, st_trend1] = st_timeframe == "" or st_timeframe == "Chart" ? 
     supertrend_calc(st_period, st_multiplier) : 
     request.security(syminfo.tickerid, st_timeframe, supertrend_calc(st_period, st_multiplier))

[supertrend2, st_trend2] = st2_timeframe == "" or st2_timeframe == "Chart" ? 
     supertrend_calc(st2_period, st2_multiplier) : 
     request.security(syminfo.tickerid, st2_timeframe, supertrend_calc(st2_period, st2_multiplier))

// Initialize SuperTrend signals
st_long_signal = false
st_short_signal = false
st2_long_signal = false
st2_short_signal = false // Объявлена как bool

supertrend_filter_passed = true // Должна быть true по умолчанию, если фильтр не используется или пройден
if use_supertrend
    // Убедимся, что st_trend1 это 1 или -1. Если na, сигнал будет false.
    is_st_trend1_up = nz(st_trend1) == 1
    is_st_trend1_down = nz(st_trend1) == -1

    st_long_signal := not opposite_st_signal ? is_st_trend1_up : is_st_trend1_down
    st_short_signal := not opposite_st_signal ? is_st_trend1_down : is_st_trend1_up

supertrend2_filter_passed = true // Должна быть true по умолчанию
if use_supertrend2
    // Убедимся, что st_trend2 это 1 или -1. Если na, сигнал будет false.
    is_st_trend2_up = nz(st_trend2) == 1 
    is_st_trend2_down = nz(st_trend2) == -1

    st2_long_signal := not opposite_st2_signal ? is_st_trend2_up : is_st_trend2_down
    st2_short_signal := not opposite_st2_signal ? is_st_trend2_down : is_st_trend2_up 

// Moving Averages
ma1_calc = ma_timeframe == "" or ma_timeframe == "Not Active" or ma_timeframe == "Chart" ? 
     ma_func(ma1_source, ma1_length, ma1_type) : 
     request.security(syminfo.tickerid, ma_timeframe, ma_func(ma1_source, ma1_length, ma1_type))

ma2_calc = ma_timeframe == "" or ma_timeframe == "Not Active" or ma_timeframe == "Chart" ? 
     ma_func(ma2_source, ma2_length, ma2_type) : 
     request.security(syminfo.tickerid, ma_timeframe, ma_func(ma2_source, ma2_length, ma2_type))

// MA Cross signals
ma_cross_up = ta.crossover(ma1_calc, ma2_calc)
ma_cross_down = ta.crossunder(ma1_calc, ma2_calc)

// Update MA signal memory
if use_ma_cross
    if ma_cross_up and not opposite_ma_cross
        ma_long_signal_bar := bar_index
    if ma_cross_down and not opposite_ma_cross
        ma_short_signal_bar := bar_index
    if ma_cross_up and opposite_ma_cross
        ma_short_signal_bar := bar_index
    if ma_cross_down and opposite_ma_cross
        ma_long_signal_bar := bar_index

// MA1 Filter
ma1_filter_passed = true
if use_ma1_filter
    ma1_long_condition = not opposite_ma1_filter ? close > ma1_calc : close < ma1_calc
    ma1_short_condition = not opposite_ma1_filter ? close < ma1_calc : close > ma1_calc
    ma1_filter_passed := true // Will be used in final logic

// Channels (Keltner/Bollinger)
channel_filter_passed = true
channel_long_signal = false
channel_short_signal = false

if use_channel
    upper_breach = false
    lower_breach = false
    
    if channel_type == "Keltner Channel"
        keltner_ma = ta.sma(close, keltner_length)
        keltner_range = ta.atr(keltner_length) * keltner_mult
        keltner_upper = keltner_ma + keltner_range
        keltner_lower = keltner_ma - keltner_range
        
        if channel_conditions == "Wick out of bands"
            upper_breach := high > keltner_upper
            lower_breach := low < keltner_lower
        else
            upper_breach := close > keltner_upper
            lower_breach := close < keltner_lower
    else
        bb_basis = ta.sma(close, bb_length)
        bb_dev = bb_deviation * ta.stdev(close, bb_length)
        bb_upper = bb_basis + bb_dev
        bb_lower = bb_basis - bb_dev
        
        if channel_conditions == "Wick out of bands"
            upper_breach := high > bb_upper
            lower_breach := low < bb_lower
        else
            upper_breach := close > bb_upper
            lower_breach := close < bb_lower
            
    if channel_rebound == "Rebound"
        channel_long_signal := lower_breach
        channel_short_signal := upper_breach
    else
        channel_long_signal := upper_breach
        channel_short_signal := lower_breach

// RSI calculations with timeframes
rsi_calc = rsi_timeframe == "" or rsi_timeframe == "Chart" ? 
     ta.rsi(close, rsi_length) : 
     request.security(syminfo.tickerid, rsi_timeframe, ta.rsi(close, rsi_length))

// RSI Cross Signals with Signal Memory
rsi_cross_up = ta.crossover(rsi_calc, rsi_long_level)
rsi_cross_down = ta.crossunder(rsi_calc, rsi_short_level)

// Update RSI signal memory
if use_rsi_cross
    if rsi_cross_up and not opposite_rsi_cross
        rsi_long_signal_bar := bar_index
    if rsi_cross_down and not opposite_rsi_cross
        rsi_short_signal_bar := bar_index
    if rsi_cross_up and opposite_rsi_cross
        rsi_short_signal_bar := bar_index
    if rsi_cross_down and opposite_rsi_cross
        rsi_long_signal_bar := bar_index

// RSI Range filters
rsi_long_range_passed = not use_rsi_long_range or (rsi_calc >= rsi_long_more and rsi_calc <= rsi_long_less)
rsi_short_range_passed = not use_rsi_short_range or (rsi_calc <= rsi_short_less and rsi_calc >= rsi_short_more)

// Stochastic calculations
stoch_k_raw = ta.stoch(close, high, low, stoch_k_length)
stoch_k_calc = ta.sma(stoch_k_raw, stoch_k_smooth)
stoch_d_calc = ta.sma(stoch_k_calc, stoch_d_smooth)

// Stochastic with timeframe
if stoch_timeframe != "" and stoch_timeframe != "Not Active" and stoch_timeframe != "Chart"
    [stoch_k_tf, stoch_d_tf] = request.security(syminfo.tickerid, stoch_timeframe, [stoch_k_calc, stoch_d_calc])
    stoch_k_calc := stoch_k_tf
    stoch_d_calc := stoch_d_tf

// Stochastic cross signals
stoch_cross_up = ta.crossover(stoch_k_calc, stoch_long_level)
stoch_cross_down = ta.crossunder(stoch_k_calc, stoch_short_level)
stoch_kd_cross_up = ta.crossover(stoch_k_calc, stoch_d_calc)
stoch_kd_cross_down = ta.crossunder(stoch_k_calc, stoch_d_calc)

// Update Stochastic signal memory
if use_stoch_cross_level
    if stoch_cross_up
        stoch_long_signal_bar := bar_index
    if stoch_cross_down
        stoch_short_signal_bar := bar_index

if use_stoch_kd_cross
    if stoch_kd_cross_up and not opposite_stoch_kd
        stoch_kd_long_signal_bar := bar_index
    if stoch_kd_cross_down and not opposite_stoch_kd
        stoch_kd_short_signal_bar := bar_index
    if stoch_kd_cross_up and opposite_stoch_kd
        stoch_kd_short_signal_bar := bar_index
    if stoch_kd_cross_down and opposite_stoch_kd
        stoch_kd_long_signal_bar := bar_index

// Stochastic Range filters
stoch_long_range_passed = not use_stoch_range_filter or (stoch_d_calc >= stoch_long_more and stoch_d_calc <= stoch_long_less)
stoch_short_range_passed = not use_stoch_range_filter or (stoch_d_calc <= stoch_short_less and stoch_d_calc >= stoch_short_more)

// RVI calculations
price_change = ta.change(close)
price_stdev = ta.stdev(close, rvi_length)
rvi_upward = price_change > 0 ? price_stdev : 0
rvi_downward = price_change <= 0 ? price_stdev : 0
rvi_up_smooth = smoothing_func(rvi_upward, rvi_ma_length, rvi_type)
rvi_down_smooth = smoothing_func(rvi_downward, rvi_ma_length, rvi_type)
rvi_denominator = rvi_up_smooth + rvi_down_smooth
rvi_value = rvi_denominator != 0 ? 100 * rvi_up_smooth / rvi_denominator : 50

if rvi_timeframe != "" and rvi_timeframe != "Chart"
    rvi_value := request.security(syminfo.tickerid, rvi_timeframe, rvi_value)

rvi_long_range_passed = not use_rvi_long_range or (rvi_value >= rvi_long_more and rvi_value <= rvi_long_less)
rvi_short_range_passed = not use_rvi_short_range or (rvi_value <= rvi_short_less and rvi_value >= rvi_short_more)

// MFI calculations
mfi_calc = ta.mfi(hlc3, mfi_length)

if mfi_timeframe != "" and mfi_timeframe != "Chart"
    mfi_calc := request.security(syminfo.tickerid, mfi_timeframe, mfi_calc)

mfi_long_range_passed = not use_mfi_long_range or (mfi_calc >= mfi_long_more and mfi_calc <= mfi_long_less)
mfi_short_range_passed = not use_mfi_short_range or (mfi_calc <= mfi_short_less and mfi_calc >= mfi_short_more)

// CCI calculations
cci_calc = ta.cci(hlc3, cci_length)

if cci_timeframe != "" and cci_timeframe != "Chart"
    cci_calc := request.security(syminfo.tickerid, cci_timeframe, cci_calc)

cci_long_range_passed = not use_cci_long_range or (cci_calc >= cci_long_more and cci_calc <= cci_long_less)
cci_short_range_passed = not use_cci_short_range or (cci_calc <= cci_short_less and cci_calc >= cci_short_more)

// DMI calculations
dmi_plus = ta.rma(math.max(high - high[1], 0), dmi_period)
dmi_minus = ta.rma(math.max(low[1] - low, 0), dmi_period)
dmi_sum = dmi_plus + dmi_minus
di_plus = dmi_sum != 0 ? 100 * dmi_plus / dmi_sum : 0
di_minus = dmi_sum != 0 ? 100 * dmi_minus / dmi_sum : 0
di_sum = di_plus + di_minus
dx = di_sum != 0 ? 100 * math.abs(di_plus - di_minus) / di_sum : 0
adx = ta.rma(dx, adx_smooth_period)

if dmi_timeframe != "" and dmi_timeframe != "Chart"
    [di_plus_tf, di_minus_tf, adx_tf] = request.security(syminfo.tickerid, dmi_timeframe, [di_plus, di_minus, adx])
    di_plus := di_plus_tf
    di_minus := di_minus_tf
    adx := adx_tf

dmi_long_value = dmi_long_line == "DI+" ? di_plus : dmi_long_line == "DI-" ? di_minus : adx
dmi_short_value = dmi_short_line == "DI+" ? di_plus : dmi_short_line == "DI-" ? di_minus : adx

dmi_long_range_passed = not use_dmi_long_range or (dmi_long_value >= dmi_long_more and dmi_long_value <= dmi_long_less)
dmi_short_range_passed = not use_dmi_short_range or (dmi_short_value <= dmi_short_less and dmi_short_value >= dmi_short_more)

// Chaikin Money Flow
ad = close == high and close == low or high == low ? 0 : ((2 * close - low - high) / (high - low)) * volume
cmf_calc = ta.sma(ad, cmf_period) / ta.sma(volume, cmf_period) * 100

if cmf_timeframe != "" and cmf_timeframe != "Chart"
    cmf_calc := request.security(syminfo.tickerid, cmf_timeframe, cmf_calc)

// CMF Cross signals
cmf_cross_up = ta.crossover(cmf_calc, cmf_cross_level)
cmf_cross_down = ta.crossunder(cmf_calc, cmf_cross_level)

// Update CMF signal memory
if use_cmf_cross
    if cmf_cross_up
        cmf_long_signal_bar := bar_index
    if cmf_cross_down
        cmf_short_signal_bar := bar_index

cmf_long_range_passed = not use_cmf_long_range or (cmf_calc >= cmf_long_more and cmf_calc <= cmf_long_less)
cmf_short_range_passed = not use_cmf_short_range or (cmf_calc <= cmf_short_less and cmf_calc >= cmf_short_more)

// Balance of Power
bop_raw = close == open ? 0 : (close - open) / (high - low)
bop_calc = ta.sma(bop_raw, bop_smooth_length) * 100

if bop_timeframe != "" and bop_timeframe != "Chart"
    bop_calc := request.security(syminfo.tickerid, bop_timeframe, bop_calc)

// BOP Cross signals
bop_cross_up = ta.crossover(bop_calc, bop_cross_level)
bop_cross_down = ta.crossunder(bop_calc, bop_cross_level)

// Update BOP signal memory
if use_bop_cross
    if bop_cross_up
        bop_long_signal_bar := bar_index
    if bop_cross_down
        bop_short_signal_bar := bar_index

bop_long_range_passed = not use_bop_long_range or (bop_calc >= bop_long_more and bop_calc <= bop_long_less)
bop_short_range_passed = not use_bop_short_range or (bop_calc <= bop_short_less and bop_calc >= bop_short_more)

// SMIO calculations
smio_short_ma = ta.ema(close, smio_short_length)
smio_long_ma = ta.ema(close, smio_long_length)
smio_diff = (smio_short_ma - smio_long_ma) / smio_long_ma * 100
smio_calc = ta.sma(smio_diff, smio_signal_length)

if smio_timeframe != "" and smio_timeframe != "Chart"
    smio_calc := request.security(syminfo.tickerid, smio_timeframe, smio_calc)

smio_long_range_passed = not use_smio_long_range or (smio_calc >= smio_long_more and smio_calc <= smio_long_less)
smio_short_range_passed = not use_smio_short_range or (smio_calc <= smio_short_less and smio_calc >= smio_short_more)

// QQE Calculations
qqe_rsi = ta.rsi(close, qqe_rsi_length)
qqe_rsi_ma = ta.ema(qqe_rsi, qqe_rsi_smooth)
qqe_atr_rsi = math.abs(qqe_rsi_ma[1] - qqe_rsi_ma)
qqe_ma_atr_rsi = ta.ema(qqe_atr_rsi, qqe_rsi_length * 2 - 1)
qqe_dar = ta.ema(qqe_ma_atr_rsi, qqe_rsi_length * 2 - 1) * qqe_delta_mult

qqe_longband = 0.0
qqe_shortband = 0.0
qqe_trend = 0

qqe_newshortband = qqe_rsi_ma + qqe_dar
qqe_newlongband = qqe_rsi_ma - qqe_dar
qqe_longband := qqe_rsi_ma[1] > qqe_longband[1] and qqe_rsi_ma > qqe_longband[1] ? math.max(qqe_longband[1], qqe_newlongband) : qqe_newlongband
qqe_shortband := qqe_rsi_ma[1] < qqe_shortband[1] and qqe_rsi_ma < qqe_shortband[1] ? math.min(qqe_shortband[1], qqe_newshortband) : qqe_newshortband

qqe_cross_1 = ta.cross(qqe_longband[1], qqe_rsi_ma)
qqe_trend := ta.cross(qqe_rsi_ma, qqe_shortband[1]) ? 1 : qqe_cross_1 ? -1 : nz(qqe_trend[1], 1)

qqe_fast_atr_rsi_tl = qqe_trend == 1 ? qqe_longband : qqe_shortband

// QQE Signals
qqe_long_signal = qqe_fast_atr_rsi_tl < qqe_rsi_ma and qqe_fast_atr_rsi_tl[1] >= qqe_rsi_ma[1]
qqe_short_signal = qqe_fast_atr_rsi_tl > qqe_rsi_ma and qqe_fast_atr_rsi_tl[1] <= qqe_rsi_ma[1]

// Update QQE signal memory
if use_qqe
    if qqe_long_signal and not opposite_qqe
        qqe_long_signal_bar := bar_index
    if qqe_short_signal and not opposite_qqe
        qqe_short_signal_bar := bar_index
    if qqe_long_signal and opposite_qqe
        qqe_short_signal_bar := bar_index
    if qqe_short_signal and opposite_qqe
        qqe_long_signal_bar := bar_index

// MACD calculations
[macd_line, macd_signal_line, macd_hist] = ta.macd(macd_source, macd_fast, macd_slow, macd_signal)

// MACD Signals
macd_cross_signal_up = ta.crossover(macd_line, macd_signal_line)
macd_cross_signal_down = ta.crossunder(macd_line, macd_signal_line)
macd_cross_zero_up = ta.crossover(macd_line, macd_cross_level)
macd_cross_zero_down = ta.crossunder(macd_line, macd_cross_level)

// Update MACD signal memory
if (use_macd_cross_signal or use_macd_cross_level) and not disable_macd_memory
    if (macd_cross_signal_up or macd_cross_zero_up) and not (opposite_macd_signal or opposite_macd_level)
        macd_long_signal_bar := bar_index
    if (macd_cross_signal_down or macd_cross_zero_down) and not (opposite_macd_signal or opposite_macd_level)
        macd_short_signal_bar := bar_index
    if (macd_cross_signal_up or macd_cross_zero_up) and (opposite_macd_signal or opposite_macd_level)
        macd_short_signal_bar := bar_index
    if (macd_cross_signal_down or macd_cross_zero_down) and (opposite_macd_signal or opposite_macd_level)
        macd_long_signal_bar := bar_index

// Linear Regression Channel
lrc_linreg = ta.linreg(lrc_source, lrc_length, 0)
lrc_stddev = ta.stdev(lrc_source, lrc_length)
lrc_upper = lrc_linreg + lrc_deviation * lrc_stddev
lrc_lower = lrc_linreg - lrc_deviation * lrc_stddev

// LRC signals
lrc_upper_breach = close > lrc_upper
lrc_lower_breach = close < lrc_lower

// LRC slope
lrc_slope = (lrc_linreg - lrc_linreg[1])
lrc_slope_up = lrc_slope > 0
lrc_slope_down = lrc_slope < 0

lrc_slope_ok = lrc_slope_direction == "Allow_All" or 
               (lrc_slope_direction == "Only_UP" and lrc_slope_up) or 
               (lrc_slope_direction == "Only_DOWN" and lrc_slope_down)

lrc_long_signal = false
lrc_short_signal = false

if use_lrc and lrc_slope_ok
    if lrc_rebound_breakout == "Rebound"
        lrc_long_signal := lrc_lower_breach
        lrc_short_signal := lrc_upper_breach
    else
        lrc_long_signal := lrc_upper_breach
        lrc_short_signal := lrc_lower_breach
        
    // Update LRC signal memory
    if not disable_lrc_memory
        if lrc_long_signal
            lrc_long_signal_bar := bar_index
        if lrc_short_signal
            lrc_short_signal_bar := bar_index

// Momentum calculations
momentum_calc = ta.mom(momentum_source, momentum_tf_long)

if momentum_timeframe != "" and momentum_timeframe != "Chart"
    momentum_calc := request.security(syminfo.tickerid, momentum_timeframe, momentum_calc)

momentum_long_range_passed = not use_momentum_long_range or (momentum_calc >= momentum_long_more and momentum_calc <= momentum_long_less)
momentum_short_range_passed = not use_momentum_short_range or (momentum_calc <= momentum_short_less and momentum_calc >= momentum_short_more)

// External Indicators
ext1_value = external1_source
ext2_value = external2_source

external_long_passed = true
if use_external_longs
    condition1_value = ext1a_compare == "Value" ? ext1a_value : ext2_value
    condition1_met = compare_values(ext1_value, ext1a_condition, condition1_value)
    
    condition2_met = true
    if use_ext2_longs
        condition2_value = ext1b_compare == "Value" ? ext1b_value : ext2_value
        condition2_met := compare_values(ext1_value, ext1b_condition, condition2_value)
    
    condition3_met = true
    if use_ext3_longs
        condition3_value = ext2c_compare == "Value" ? ext2c_value : ext1_value
        condition3_met := compare_values(ext2_value, ext2c_condition, condition3_value)
    
    external_long_passed := condition1_met and condition2_met and condition3_met

external_short_passed = true
if use_external_shorts
    condition1_value = ext1d_compare == "Value" ? ext1d_value : ext2_value
    condition1_met = compare_values(ext1_value, ext1d_condition, condition1_value)
    
    condition2_met = true
    if use_ext2_shorts
        condition2_value = ext1e_compare == "Value" ? ext1e_value : ext2_value
        condition2_met := compare_values(ext1_value, ext1e_condition, condition2_value)
    
    condition3_met = true
    if use_ext3_shorts
        condition3_value = ext2f_compare == "Value" ? ext2f_value : ext1_value
        condition3_met := compare_values(ext2_value, ext2f_condition, condition3_value)
    
    external_short_passed := condition1_met and condition2_met and condition3_met

// Candlestick Pattern Detection (simplified version)
candle_pattern_long = false
candle_pattern_short = false

if use_candlestick_patterns
    // Basic pattern detection - can be expanded
    body = math.abs(close - open)
    upper_shadow = high - math.max(close, open)
    lower_shadow = math.min(close, open) - low
    avg_body = ta.sma(body, 10)
    
    // Hammer pattern
    if hammer_long
        candle_pattern_long := lower_shadow > 2 * body and upper_shadow < body and close > open and body > avg_body * 0.3
        
    // Shooting star pattern
    if shooting_star_short
        candle_pattern_short := upper_shadow > 2 * body and lower_shadow < body and close < open and body > avg_body * 0.3
        
// Engulfing patterns
    if engulfing_both
        bullish_engulfing = close > open and close[1] < open[1] and close > open[1] and open < close[1]
        bearish_engulfing = close < open and close[1] > open[1] and close < open[1] and open > close[1]
        candle_pattern_long := candle_pattern_long or bullish_engulfing
        candle_pattern_short := candle_pattern_short or bearish_engulfing
        
    // Doji patterns
    if doji_both
        body_size = math.abs(close - open)
        total_range = high - low
        is_doji = total_range > 0 and body_size <= total_range * 0.1
        candle_pattern_long := candle_pattern_long or is_doji
        candle_pattern_short := candle_pattern_short or is_doji
        
    // Update candlestick signal memory
    if not disable_candle_memory
        if candle_pattern_long
            candle_long_signal_bar := bar_index
        if candle_pattern_short
            candle_short_signal_bar := bar_index

// Divergence Detection (simplified)
div_long_signal = false
div_short_signal = false

if use_divergence
    rsi_for_div = ta.rsi(close, 14)
    pivot_high = ta.pivothigh(high, div_pivot_interval, div_pivot_interval)
    pivot_low = ta.pivotlow(low, div_pivot_interval, div_pivot_interval)
    
    // Pre-calculate valuewhen calls
    last_pivot_low_price = ta.valuewhen(not na(pivot_low), low, 1)
    last_pivot_low_rsi = ta.valuewhen(not na(pivot_low), rsi_for_div, 1)
    current_pivot_low_rsi = ta.valuewhen(not na(pivot_low), rsi_for_div, 0)
    
    last_pivot_high_price = ta.valuewhen(not na(pivot_high), high, 1)
    last_pivot_high_rsi = ta.valuewhen(not na(pivot_high), rsi_for_div, 1)
    current_pivot_high_rsi = ta.valuewhen(not na(pivot_high), rsi_for_div, 0)
    
    // Bullish divergence: price makes lower low, RSI makes higher low
    if not na(pivot_low) and not na(last_pivot_low_price) and not na(last_pivot_low_rsi)
        if low < last_pivot_low_price and current_pivot_low_rsi > last_pivot_low_rsi
            div_long_signal := true
            
    // Bearish divergence: price makes higher high, RSI makes lower high  
    if not na(pivot_high) and not na(last_pivot_high_price) and not na(last_pivot_high_rsi)
        if high > last_pivot_high_price and current_pivot_high_rsi < last_pivot_high_rsi
            div_short_signal := true
            
    // Update divergence signal memory
    if activate_div_memory
        if div_long_signal
            div_long_signal_bar := bar_index
        if div_short_signal
            div_short_signal_bar := bar_index

// Pivot Levels
var array<float> resistance_levels = array.new<float>()
var array<float> support_levels = array.new<float>()

pivot_filter_passed = true
pivot_signal_long = false
pivot_signal_short = false

// Calculate pivot points
pivot_highs_calc = ta.pivothigh(high, pivot_left, pivot_right)
pivot_lows_calc = ta.pivotlow(low, pivot_left, pivot_right)

// Apply timeframe if specified
pivot_highs_final = pivot_timeframe == "" or pivot_timeframe == "Chart" ? 
     pivot_highs_calc : 
     request.security(syminfo.tickerid, pivot_timeframe, pivot_highs_calc)
     
pivot_lows_final = pivot_timeframe == "" or pivot_timeframe == "Chart" ? 
     pivot_lows_calc : 
     request.security(syminfo.tickerid, pivot_timeframe, pivot_lows_calc)

// Store pivot levels
if not na(pivot_highs_final) and array.size(resistance_levels) < pivot_limit
    array.push(resistance_levels, pivot_highs_final)
if not na(pivot_lows_final) and array.size(support_levels) < pivot_limit
    array.push(support_levels, pivot_lows_final)

// Check proximity to levels
near_resistance = false
near_support = false

if array.size(resistance_levels) > 0
    for i = 0 to array.size(resistance_levels) - 1
        level = array.get(resistance_levels, i)
        distance_percent = math.abs(close - level) / close * 100
        if distance_percent <= near_distance_execute
            pivot_signal_short := true
        if distance_percent <= near_distance_block
            near_resistance := true

if array.size(support_levels) > 0
    for i = 0 to array.size(support_levels) - 1
        level = array.get(support_levels, i)
        distance_percent = math.abs(close - level) / close * 100
        if distance_percent <= near_distance_execute
            pivot_signal_long := true
        if distance_percent <= near_distance_block
            near_support := true

// Apply pivot filters
if not_open_near_level
    pivot_filter_passed := not (near_resistance or near_support)

// Accumulation Areas (simplified)
acc_filter_passed = true
acc_signal_long = false
acc_signal_short = false

if use_accumulation
    // Simple accumulation detection based on price range
    recent_high = ta.highest(high, acc_backtrack)
    recent_low = ta.lowest(low, acc_backtrack)
    price_range = recent_high - recent_low
    current_range = high - low
    
    // Accumulation when range is compressed
    is_accumulation = current_range < price_range * 0.3
    bars_since_accumulation = ta.barssince(is_accumulation)
    
    if acc_breakout_signal and bars_since_accumulation <= acc_min_bars
        if close > recent_high
            acc_signal_long := true
        if close < recent_low
            acc_signal_short := true
            
    if acc_breakout_opposite and bars_since_accumulation <= acc_min_bars
        if close > recent_high
            acc_signal_short := true
        if close < recent_low
            acc_signal_long := true

// All filters combined
base_filters_passed = time_trade_allowed and vol_filter_passed and highlow_filter_passed and block_worse_filter_passed and atr_filter_passed and pivot_filter_passed and acc_filter_passed

// Range filters for long
rsi_stoch_long = rsi_long_range_passed and stoch_long_range_passed
rvi_mfi_long = rvi_long_range_passed and mfi_long_range_passed
cci_dmi_long = cci_long_range_passed and dmi_long_range_passed
cmf_bop_long = cmf_long_range_passed and bop_long_range_passed
smio_momentum_long = smio_long_range_passed and momentum_long_range_passed
long_range_filters_passed = rsi_stoch_long and rvi_mfi_long and cci_dmi_long and cmf_bop_long and smio_momentum_long and external_long_passed

// Range filters for short
rsi_stoch_short = rsi_short_range_passed and stoch_short_range_passed
rvi_mfi_short = rvi_short_range_passed and mfi_short_range_passed
cci_dmi_short = cci_short_range_passed and dmi_short_range_passed
cmf_bop_short = cmf_short_range_passed and bop_short_range_passed
smio_momentum_short = smio_short_range_passed and momentum_short_range_passed
short_range_filters_passed = rsi_stoch_short and rvi_mfi_short and cci_dmi_short and cmf_bop_short and smio_momentum_short and external_short_passed

// Final filter combination
all_filters_passed_long = base_filters_passed and long_range_filters_passed
all_filters_passed_short = base_filters_passed and short_range_filters_passed

// ===============================
// SIGNAL EVALUATION WITH MEMORY
// ===============================

// Count active and met conditions
var int active_conditions_long = 0
var int met_conditions_long = 0
var int active_conditions_short = 0
var int met_conditions_short = 0

// Reset counters
active_conditions_long := 0
met_conditions_long := 0
active_conditions_short := 0
met_conditions_short := 0

// RSI Cross Signals
if use_rsi_cross
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = activate_rsi_memory ? rsi_memory_bars : 0
    
    // Calculate RSI conditions separately
    rsi_long_condition_normal = rsi_cross_up and not opposite_rsi_cross
    rsi_long_condition_opposite = rsi_cross_down and opposite_rsi_cross
    rsi_long_condition_immediate = rsi_long_condition_normal or rsi_long_condition_opposite
    rsi_long_condition_memory = bar_index - rsi_long_signal_bar <= memory_bars
    
    rsi_short_condition_normal = rsi_cross_down and not opposite_rsi_cross
    rsi_short_condition_opposite = rsi_cross_up and opposite_rsi_cross
    rsi_short_condition_immediate = rsi_short_condition_normal or rsi_short_condition_opposite
    rsi_short_condition_memory = bar_index - rsi_short_signal_bar <= memory_bars
    
    rsi_long_active = activate_rsi_memory ? rsi_long_condition_memory : rsi_long_condition_immediate
    rsi_short_active = activate_rsi_memory ? rsi_short_condition_memory : rsi_short_condition_immediate
    
    if rsi_long_active
        met_conditions_long += 1
    if rsi_short_active
        met_conditions_short += 1

// QQE Signals
if use_qqe
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = disable_qqe_memory ? 0 : 5
    qqe_long_active = disable_qqe_memory ? 
                      (qqe_long_signal and not opposite_qqe) or (qqe_short_signal and opposite_qqe) : 
                      bar_index - qqe_long_signal_bar <= memory_bars
    qqe_short_active = disable_qqe_memory ? 
                       (qqe_short_signal and not opposite_qqe) or (qqe_long_signal and opposite_qqe) : 
                       bar_index - qqe_short_signal_bar <= memory_bars
    
    if qqe_long_active
        met_conditions_long += 1
    if qqe_short_active
        met_conditions_short += 1

// MACD Signals
if use_macd_cross_signal or use_macd_cross_level
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = disable_macd_memory ? 0 : 5
    
    // Calculate MACD conditions for long
    macd_long_condition_normal = (macd_cross_signal_up or macd_cross_zero_up) and not (opposite_macd_signal or opposite_macd_level)
    macd_long_condition_opposite = (macd_cross_signal_down or macd_cross_zero_down) and (opposite_macd_signal or opposite_macd_level)
    macd_long_condition_immediate = macd_long_condition_normal or macd_long_condition_opposite
    macd_long_condition_memory = bar_index - macd_long_signal_bar <= memory_bars
    
    macd_long_active = disable_macd_memory ? macd_long_condition_immediate : macd_long_condition_memory
    
    // Calculate MACD conditions for short
    macd_short_condition_normal = (macd_cross_signal_down or macd_cross_zero_down) and not (opposite_macd_signal or opposite_macd_level)
    macd_short_condition_opposite = (macd_cross_signal_up or macd_cross_zero_up) and (opposite_macd_signal or opposite_macd_level)
    macd_short_condition_immediate = macd_short_condition_normal or macd_short_condition_opposite
    macd_short_condition_memory = bar_index - macd_short_signal_bar <= memory_bars
    
    macd_short_active = disable_macd_memory ? macd_short_condition_immediate : macd_short_condition_memory
    
    if macd_long_active
        met_conditions_long += 1
    if macd_short_active
        met_conditions_short += 1

// Moving Average Signals
if use_ma_cross
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = activate_ma_memory ? ma_memory_bars : 0
    
    // Calculate MA conditions separately
    ma_long_condition_normal = ma_cross_up and not opposite_ma_cross
    ma_long_condition_opposite = ma_cross_down and opposite_ma_cross
    ma_long_condition_immediate = ma_long_condition_normal or ma_long_condition_opposite
    ma_long_condition_memory = bar_index - ma_long_signal_bar <= memory_bars
    
    ma_short_condition_normal = ma_cross_down and not opposite_ma_cross
    ma_short_condition_opposite = ma_cross_up and opposite_ma_cross
    ma_short_condition_immediate = ma_short_condition_normal or ma_short_condition_opposite
    ma_short_condition_memory = bar_index - ma_short_signal_bar <= memory_bars
    
    ma_long_active = activate_ma_memory ? ma_long_condition_memory : ma_long_condition_immediate
    ma_short_active = activate_ma_memory ? ma_short_condition_memory : ma_short_condition_immediate
    
    if ma_long_active
        met_conditions_long += 1
    if ma_short_active
        met_conditions_short += 1

// Stochastic Cross Level Signals
if use_stoch_cross_level
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = activate_stoch_cross_memory ? stoch_cross_memory_bars : 0
    stoch_long_condition_memory = bar_index - stoch_long_signal_bar <= memory_bars
    stoch_short_condition_memory = bar_index - stoch_short_signal_bar <= memory_bars
    
    stoch_long_active = activate_stoch_cross_memory ? stoch_long_condition_memory : stoch_cross_up
    stoch_short_active = activate_stoch_cross_memory ? stoch_short_condition_memory : stoch_cross_down
    
    if stoch_long_active
        met_conditions_long += 1
    if stoch_short_active
        met_conditions_short += 1

// Stochastic K/D Cross Signals
if use_stoch_kd_cross
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = activate_stoch_kd_memory ? stoch_kd_memory_bars : 0
    
    // Calculate conditions separately for clarity
    stoch_kd_long_condition_normal = stoch_kd_cross_up and not opposite_stoch_kd
    stoch_kd_long_condition_opposite = stoch_kd_cross_down and opposite_stoch_kd
    stoch_kd_long_condition_immediate = stoch_kd_long_condition_normal or stoch_kd_long_condition_opposite
    stoch_kd_long_condition_memory = bar_index - stoch_kd_long_signal_bar <= memory_bars
    
    stoch_kd_short_condition_normal = stoch_kd_cross_down and not opposite_stoch_kd
    stoch_kd_short_condition_opposite = stoch_kd_cross_up and opposite_stoch_kd
    stoch_kd_short_condition_immediate = stoch_kd_short_condition_normal or stoch_kd_short_condition_opposite
    stoch_kd_short_condition_memory = bar_index - stoch_kd_short_signal_bar <= memory_bars
    
    stoch_kd_long_active = activate_stoch_kd_memory ? stoch_kd_long_condition_memory : stoch_kd_long_condition_immediate
    stoch_kd_short_active = activate_stoch_kd_memory ? stoch_kd_short_condition_memory : stoch_kd_short_condition_immediate
    
    if stoch_kd_long_active
        met_conditions_long += 1
    if stoch_kd_short_active
        met_conditions_short += 1

// Linear Regression Channel Signals
if use_lrc
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = disable_lrc_memory ? 0 : lrc_memory_bars
    lrc_long_condition_memory = bar_index - lrc_long_signal_bar <= memory_bars
    lrc_short_condition_memory = bar_index - lrc_short_signal_bar <= memory_bars
    
    lrc_long_active = disable_lrc_memory ? lrc_long_signal : lrc_long_condition_memory
    lrc_short_active = disable_lrc_memory ? lrc_short_signal : lrc_short_condition_memory
    
    if lrc_long_active
        met_conditions_long += 1
    if lrc_short_active
        met_conditions_short += 1

// CMF Cross Signals
if use_cmf_cross
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = disable_cmf_memory ? 0 : 5
    cmf_long_condition_memory = bar_index - cmf_long_signal_bar <= memory_bars
    cmf_short_condition_memory = bar_index - cmf_short_signal_bar <= memory_bars
    
    cmf_long_active = disable_cmf_memory ? cmf_cross_up : cmf_long_condition_memory
    cmf_short_active = disable_cmf_memory ? cmf_cross_down : cmf_short_condition_memory
    
    if cmf_long_active
        met_conditions_long += 1
    if cmf_short_active
        met_conditions_short += 1

// BOP Cross Signals
if use_bop_cross
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = disable_bop_memory ? 0 : 5
    bop_long_condition_memory = bar_index - bop_long_signal_bar <= memory_bars
    bop_short_condition_memory = bar_index - bop_short_signal_bar <= memory_bars
    
    bop_long_active = disable_bop_memory ? bop_cross_up : bop_long_condition_memory
    bop_short_active = disable_bop_memory ? bop_cross_down : bop_short_condition_memory
    
    if bop_long_active
        met_conditions_long += 1
    if bop_short_active
        met_conditions_short += 1

// Divergence Signals
if use_divergence
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = activate_div_memory ? div_memory_bars : 0
    div_long_condition_memory = bar_index - div_long_signal_bar <= memory_bars
    div_short_condition_memory = bar_index - div_short_signal_bar <= memory_bars
    
    div_long_active = activate_div_memory ? div_long_condition_memory : div_long_signal
    div_short_active = activate_div_memory ? div_short_condition_memory : div_short_signal
    
    if div_long_active
        met_conditions_long += 1
    if div_short_active
        met_conditions_short += 1

// Candlestick Pattern Signals
if use_candlestick_patterns
    active_conditions_long += 1
    active_conditions_short += 1
    
    memory_bars = disable_candle_memory ? 0 : 5
    candle_long_condition_memory = bar_index - candle_long_signal_bar <= memory_bars
    candle_short_condition_memory = bar_index - candle_short_signal_bar <= memory_bars
    
    candle_long_active = disable_candle_memory ? candle_pattern_long : candle_long_condition_memory
    candle_short_active = disable_candle_memory ? candle_pattern_short : candle_short_condition_memory
    
    if candle_long_active
        met_conditions_long += 1
    if candle_short_active
        met_conditions_short += 1

// SuperTrend Filter Integration
if use_supertrend
    all_filters_passed_long := all_filters_passed_long and st_long_signal
    all_filters_passed_short := all_filters_passed_short and st_short_signal

if use_supertrend2
    all_filters_passed_long := all_filters_passed_long and st2_long_signal
    all_filters_passed_short := all_filters_passed_short and st2_short_signal

// MA1 Filter Integration
if use_ma1_filter
    ma1_long_filter = not opposite_ma1_filter ? close > ma1_calc : close < ma1_calc
    ma1_short_filter = not opposite_ma1_filter ? close < ma1_calc : close > ma1_calc
    all_filters_passed_long := all_filters_passed_long and ma1_long_filter
    all_filters_passed_short := all_filters_passed_short and ma1_short_filter

// Channel Filter Integration
if use_channel
    all_filters_passed_long := all_filters_passed_long and channel_long_signal
    all_filters_passed_short := all_filters_passed_short and channel_short_signal

// Pivot Signal Integration
if open_near_level
    if pivot_signal_long
        met_conditions_long += 1
        active_conditions_long += 1
    if pivot_signal_short
        met_conditions_short += 1
        active_conditions_short += 1

// Accumulation Signal Integration
if use_accumulation and (acc_breakout_signal or acc_breakout_opposite)
    if acc_signal_long
        met_conditions_long += 1
        active_conditions_long += 1
    if acc_signal_short
        met_conditions_short += 1
        active_conditions_short += 1

// Entry cooldown
can_enter = bar_index - last_entry_bar_index >= min_bars_between_entries

// Check pyramiding distance
pyramiding_ok = true
if use_min_distance and strategy.position_size != 0
    avg_price = strategy.position_avg_price
    price_distance_percent = math.abs(close - avg_price) / avg_price * 100
    pyramiding_ok := price_distance_percent >= min_distance_pyramiding

// Final entry conditions
long_conditions_check = active_conditions_long > 0 and met_conditions_long == active_conditions_long
long_no_indicators = active_conditions_long == 0 and allow_entry_without_indicators
entry_conditions_met_long = long_conditions_check or long_no_indicators

short_conditions_check = active_conditions_short > 0 and met_conditions_short == active_conditions_short
short_no_indicators = active_conditions_short == 0 and allow_entry_without_indicators
entry_conditions_met_short = short_conditions_check or short_no_indicators

long_all_filters = use_long_trades and all_filters_passed_long and entry_conditions_met_long
long_final_checks = can_enter and pyramiding_ok and barstate.isconfirmed
final_long_signal = long_all_filters and long_final_checks

short_all_filters = use_short_trades and all_filters_passed_short and entry_conditions_met_short
short_final_checks = can_enter and pyramiding_ok and barstate.isconfirmed
final_short_signal = short_all_filters and short_final_checks

// ===============================
// ATR CALCULATIONS FOR SL/TP
// ===============================
atr_sl_calc = use_atr_sl ? smoothing_func(ta.atr(atr_sl_period), atr_sl_period, atr_sl_method) * atr_sl_multiplier : na
atr_tp_calc = use_atr_tp ? smoothing_func(ta.atr(atr_tp_period), atr_tp_period, atr_tp_method) * atr_tp_multiplier : na

// ===============================
// STRATEGY EXECUTION
// ===============================

// Handle indent orders
indent_order_active = use_indent_order and (not na(indent_long_price) or not na(indent_short_price))
cancel_indent = indent_order_active and bar_index - indent_order_bar >= cancel_indent_bars

if cancel_indent
    indent_long_price := na
    indent_short_price := na
    indent_order_bar := 0

// Entry execution
if final_long_signal
    if use_indent_order
        indent_long_price := close * (1 + indent_percent / 100)
        indent_order_bar := bar_index
    else
        strategy.entry("Long", strategy.long)
        last_entry_bar_index := bar_index
        entry_price := close

if final_short_signal
    if use_indent_order
        indent_short_price := close * (1 - indent_percent / 100)
        indent_order_bar := bar_index
    else
        strategy.entry("Short", strategy.short)
        last_entry_bar_index := bar_index
        entry_price := close

// Execute indent orders
if not na(indent_long_price) and low <= indent_long_price
    strategy.entry("Long", strategy.long)
    last_entry_bar_index := bar_index
    entry_price := indent_long_price
    indent_long_price := na

if not na(indent_short_price) and high >= indent_short_price
    strategy.entry("Short", strategy.short)
    last_entry_bar_index := bar_index
    entry_price := indent_short_price
    indent_short_price := na

// ===============================
// EXIT MANAGEMENT
// ===============================

// Close conditions
rsi_close_calc = rsi_close_timeframe == "" or rsi_close_timeframe == "Chart" ? 
                 ta.rsi(close, rsi_close_length) : 
                 request.security(syminfo.tickerid, rsi_close_timeframe, ta.rsi(close, rsi_close_length))

should_close_long_rsi = use_rsi_close_long and (rsi_close_calc >= rsi_cl_long_more and rsi_close_calc <= rsi_cl_long_less)
should_close_short_rsi = use_rsi_close_short and (rsi_close_calc <= rsi_cl_short_less and rsi_close_calc >= rsi_cl_short_more)

// Close by time
should_close_time = use_close_time and bar_index - last_entry_bar_index >= close_after_bars

// Close near pivot levels
should_close_pivot = false
if close_near_level and strategy.position_size != 0
    current_profit_percent = (close - strategy.position_avg_price) / strategy.position_avg_price * 100 * math.sign(strategy.position_size)
    profit_ok = not close_profit_only or current_profit_percent >= min_profit_close
    
    if profit_ok
        // Check distance to levels
        if strategy.position_size > 0 and array.size(resistance_levels) > 0
            for i = 0 to array.size(resistance_levels) - 1
                level = array.get(resistance_levels, i)
                distance_percent = math.abs(close - level) / close * 100
                if distance_percent <= near_distance_close
                    should_close_pivot := true
                    
        if strategy.position_size < 0 and array.size(support_levels) > 0
            for i = 0 to array.size(support_levels) - 1
                level = array.get(support_levels, i)
                distance_percent = math.abs(close - level) / close * 100
                if distance_percent <= near_distance_close
                    should_close_pivot := true

// Apply close conditions
if strategy.position_size > 0
    should_close_rsi_check = not close_rsi_profit_only or (close - strategy.position_avg_price) / strategy.position_avg_price * 100 >= min_profit_rsi_close
    should_close_time_check = not close_time_profit_only or (close - strategy.position_avg_price) / strategy.position_avg_price * 100 >= min_profit_time_close
    
    if (should_close_long_rsi and should_close_rsi_check) or 
       (should_close_time and should_close_time_check) or 
       should_close_pivot
        strategy.close("Long", comment="Close Condition")

if strategy.position_size < 0
    should_close_rsi_check = not close_rsi_profit_only or (strategy.position_avg_price - close) / strategy.position_avg_price * 100 >= min_profit_rsi_close
    should_close_time_check = not close_time_profit_only or (strategy.position_avg_price - close) / strategy.position_avg_price * 100 >= min_profit_time_close
    
    if (should_close_short_rsi and should_close_rsi_check) or 
       (should_close_time and should_close_time_check) or 
       should_close_pivot
        strategy.close("Short", comment="Close Condition")

        // Multiple TP or Standard TP/SL Logic
if strategy.position_size != 0
    avg_price = strategy.position_avg_price
    sl_percent_final = sl_equals_tp ? take_profit_percent : stop_loss_percent
    
    if use_multiple_tp
        // Multiple Take Profits Logic
        profit_long = (close - avg_price) / avg_price * 100
        profit_short = (avg_price - close) / avg_price * 100
        current_profit_percent = strategy.position_size > 0 ? profit_long : profit_short
        
        if not tp1_executed and current_profit_percent >= tp1_percent
            tp1_price = strategy.position_size > 0 ? avg_price * (1 + tp1_percent / 100) : avg_price * (1 - tp1_percent / 100)
            entry_name = strategy.position_size > 0 ? "Long" : "Short"
            strategy.exit("TP1", from_entry=entry_name, qty_percent=tp1_qty, limit=tp1_price)
            tp1_executed := true
            
        if not tp2_executed and current_profit_percent >= tp2_percent
            tp2_price = strategy.position_size > 0 ? avg_price * (1 + tp2_percent / 100) : avg_price * (1 - tp2_percent / 100)
            entry_name = strategy.position_size > 0 ? "Long" : "Short"
            strategy.exit("TP2", from_entry=entry_name, qty_percent=tp2_qty, limit=tp2_price)
            tp2_executed := true
            
        if not tp3_executed and current_profit_percent >= tp3_percent
            tp3_price = strategy.position_size > 0 ? avg_price * (1 + tp3_percent / 100) : avg_price * (1 - tp3_percent / 100)
            entry_name = strategy.position_size > 0 ? "Long" : "Short"
            strategy.exit("TP3", from_entry=entry_name, qty_percent=tp3_qty, limit=tp3_price)
            tp3_executed := true
            
        if not tp4_executed and current_profit_percent >= tp4_percent
            tp4_price = strategy.position_size > 0 ? avg_price * (1 + tp4_percent / 100) : avg_price * (1 - tp4_percent / 100)
            entry_name = strategy.position_size > 0 ? "Long" : "Short"
            strategy.exit("TP4", from_entry=entry_name, qty_percent=tp4_qty, limit=tp4_price)
            tp4_executed := true
    else
        // Standard TP/SL Logic
        if strategy.position_size > 0
            // Long position
            tp_level = use_atr_tp ? avg_price + atr_tp_calc : avg_price * (1 + take_profit_percent / 100)
            sl_level = use_atr_sl ? avg_price - atr_sl_calc : avg_price * (1 - sl_percent_final / 100)
            
            // Breakeven management
            if activate_breakeven and not breakeven_activated
                profit_percent = (close - avg_price) / avg_price * 100
                if profit_percent >= breakeven_activation
                    sl_level := avg_price * (1 + breakeven_level / 100)
                    breakeven_activated := true
            
            // Trailing stop
            if use_trailing_stop
                profit_percent = (close - avg_price) / avg_price * 100
                if profit_percent >= trailing_activation
                    new_trailing_level = close * (1 - trailing_distance / 100)
                    trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.max(trailing_stop_level, new_trailing_level)
                    sl_level := trailing_stop_level
            
            strategy.exit("Exit Long", limit=tp_level, stop=sl_level)
        
        if strategy.position_size < 0
            // Short position
            tp_level = use_atr_tp ? avg_price - atr_tp_calc : avg_price * (1 - take_profit_percent / 100)
            sl_level = use_atr_sl ? avg_price + atr_sl_calc : avg_price * (1 + sl_percent_final / 100)
            
            // Breakeven management
            if activate_breakeven and not breakeven_activated
                profit_percent = (avg_price - close) / avg_price * 100
                if profit_percent >= breakeven_activation
                    sl_level := avg_price * (1 - breakeven_level / 100)
                    breakeven_activated := true
            
            // Trailing stop
            if use_trailing_stop
                profit_percent = (avg_price - close) / avg_price * 100
                if profit_percent >= trailing_activation
                    new_trailing_level = close * (1 + trailing_distance / 100)
                    trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.min(trailing_stop_level, new_trailing_level)
                    sl_level := trailing_stop_level
            
            strategy.exit("Exit Short", limit=tp_level, stop=sl_level)

// Reset variables when position closes
if strategy.position_size == 0 and strategy.position_size[1] != 0
    trailing_stop_level := na
    breakeven_activated := false
    tp1_executed := false
    tp2_executed := false
    tp3_executed := false
    tp4_executed := false
    entry_price := na

// ===============================
// VISUALIZATION
// ===============================

// Pre-calculate ATR for visualization
atr_for_viz = ta.atr(14)

// Signal visualization
show_long_label = show_entry_signals and (show_all_signals or strategy.position_size == 0) and final_long_signal
show_short_label = show_entry_signals and (show_all_signals or strategy.position_size == 0) and final_short_signal

if show_long_label
    label.new(bar_index, low - atr_for_viz, "LONG\n" + str.tostring(met_conditions_long) + "/" + str.tostring(active_conditions_long), 
              color=color.green, style=label.style_label_up, textcolor=color.white, size=size.normal)

if show_short_label
    label.new(bar_index, high + atr_for_viz, "SHORT\n" + str.tostring(met_conditions_short) + "/" + str.tostring(active_conditions_short), 
              color=color.red, style=label.style_label_down, textcolor=color.white, size=size.normal)

// QQE visualization
plotshape(enable_qqe_visual and qqe_long_signal and not opposite_qqe, title="QQE Long", style=shape.labelup, location=location.belowbar, color=color.green, text="QQE", size=size.tiny)
plotshape(enable_qqe_visual and qqe_short_signal and not opposite_qqe, title="QQE Short", style=shape.labeldown, location=location.abovebar, color=color.red, text="QQE", size=size.tiny)

// MACD visualization
hline(enable_macd_visual ? 0 : na, "MACD Zero Line", color=color.gray)
plot(enable_macd_visual ? macd_line : na, title="MACD Line", color=color.blue)
plot(enable_macd_visual ? macd_signal_line : na, title="MACD Signal", color=color.red)
plot(enable_macd_visual ? macd_hist : na, title="MACD Histogram", color=color.gray, style=plot.style_histogram)

// Moving averages
plot(show_two_mas ? ma1_calc : na, "MA1", color=color.green, linewidth=1)
plot(show_two_mas ? ma2_calc : na, "MA2", color=color.red, linewidth=1)

// SuperTrend visualization
plot(show_supertrend ? supertrend1 : na, "SuperTrend", color=st_trend1 == 1 ? color.green : color.red, linewidth=2)
plot(show_supertrend2 ? supertrend2 : na, "SuperTrend TF2", color=st_trend2 == 1 ? color.blue : color.orange, linewidth=1)

// DMI visualization
plot(visualise_dmi ? di_plus : na, title="DI+", color=color.green)
plot(visualise_dmi ? di_minus : na, title="DI-", color=color.red)
plot(visualise_dmi ? adx : na, title="ADX", color=color.blue)

// Trailing stop visualization
plot(visualise_trailing ? trailing_stop_level : na, title="Trailing Stop", color=color.purple, linewidth=2, style=plot.style_circles)

// Indent order lines
if show_last_signal_lines and not na(indent_long_price)
    line.new(bar_index - 1, indent_long_price, bar_index + cancel_indent_bars, indent_long_price, 
             color=color.green, style=line.style_dashed, width=1)
if show_last_signal_lines and not na(indent_short_price)
    line.new(bar_index - 1, indent_short_price, bar_index + cancel_indent_bars, indent_short_price, 
             color=color.red, style=line.style_dashed, width=1)

// Divergence lines
if show_div_lines and use_divergence and div_long_signal
    line.new(bar_index - div_pivot_interval, low[div_pivot_interval], bar_index, low, 
             color=color.green, style=line.style_solid, width=2)
if show_div_lines and use_divergence and div_short_signal
    line.new(bar_index - div_pivot_interval, high[div_pivot_interval], bar_index, high, 
             color=color.red, style=line.style_solid, width=2)

// TP/SL visualization
tp_sl_avg_price = strategy.position_avg_price
tp_sl_percent_final = sl_equals_tp ? take_profit_percent : stop_loss_percent

tp_level_long = use_atr_tp ? tp_sl_avg_price + atr_tp_calc : tp_sl_avg_price * (1 + take_profit_percent / 100)
sl_level_long = use_atr_sl ? tp_sl_avg_price - atr_sl_calc : tp_sl_avg_price * (1 - tp_sl_percent_final / 100)
tp_level_short = use_atr_tp ? tp_sl_avg_price - atr_tp_calc : tp_sl_avg_price * (1 - take_profit_percent / 100)
sl_level_short = use_atr_sl ? tp_sl_avg_price + atr_sl_calc : tp_sl_avg_price * (1 + tp_sl_percent_final / 100)

show_long_tp_sl = show_tp_sl and strategy.position_size > 0
show_short_tp_sl = show_tp_sl and strategy.position_size < 0

plot(show_long_tp_sl ? tp_level_long : na, title="Long TP", color=color.green, linewidth=1, style=plot.style_stepline)
plot(show_long_tp_sl ? sl_level_long : na, title="Long SL", color=color.red, linewidth=1, style=plot.style_stepline)
plot(show_short_tp_sl ? tp_level_short : na, title="Short TP", color=color.green, linewidth=1, style=plot.style_stepline)
plot(show_short_tp_sl ? sl_level_short : na, title="Short SL", color=color.red, linewidth=1, style=plot.style_stepline)

// Status line with inputs (if enabled)
if inputs_in_status and barstate.islast
    active_total = active_conditions_long + active_conditions_short
    met_total = met_conditions_long + met_conditions_short
    
    status_text = "MSS | " + 
                  "Long:" + str.tostring(use_long_trades) + " " +
                  "Short:" + str.tostring(use_short_trades) + " " +
                  "TP:" + str.tostring(take_profit_percent) + "% " +
                  "SL:" + str.tostring(stop_loss_percent) + "% " +
                  "Active:" + str.tostring(active_total) + " " +
                  "Signals:" + str.tostring(met_total)
    
    var table status_table = table.new(position.top_right, 1, 1, bgcolor=color.white, border_width=1)
    if not na(status_table)
        table.cell(status_table, 0, 0, status_text, text_color=color.black, text_size=size.small)
